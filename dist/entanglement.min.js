class Entanglement{static version="0.0.4";static getValue(i){let t=i;return isNaN(i)&&(t=i.rand()),t}static getInt(i){let t=i;return isNaN(i)&&(t=random(i.min,i.max+1)),Math.floor(t)}}class Point{constructor(i,t){this.x=i,this.y=t}add(i){this.x+=i.x,this.y+=i.y}rotate(i,t){const s=radians(i),e=this.x-t.x,n=this.y-t.y;this.x=e*cos(s)-n*sin(s)+t.x,this.y=e*sin(s)+n*cos(s)+t.y}vary(i){return this.x+=random(-i,i),this.y+=random(-i,i),this}}class Polar{constructor(i,t){this.r=i,this.a=t}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(i){let t=this.toPoint();return t.add(i),t}}class Line{constructor(i,t){this.begin=i,this.end=t}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(i){let t=[this.begin];const s=this.begin.x-this.end.x,e=this.begin.y-this.end.y;for(let n=1;n<=i;n++)t.push(new Point(this.begin.x-n*s/i,this.begin.y-n*e/i));return t}handDrawn(i,t){if(void 0===i&&(i=Math.floor(this.length()/6)),0===i)return[this.begin,this.end];void 0===t&&(t=1);let s=[];const e=this.divide(i);for(let i=0;i<e.length;i++)0===i||i===e.length-1?s.push(e[i]):s.push(e[i].vary(t));return s}intersection(i){const t=(i.end.y-i.begin.y)*(this.end.x-this.begin.x)-(i.end.x-i.begin.x)*(this.end.y-this.begin.y);if(0==t)return;const s=this.begin.y-i.begin.y,e=this.begin.x-i.begin.x,n=((i.end.x-i.begin.x)*s-(i.end.y-i.begin.y)*e)/t,h=this.begin.x+n*(this.end.x-this.begin.x),o=this.begin.y+n*(this.end.y-this.begin.y);return new Point(h,o)}}class Box{constructor(i,t,s){this.position=i,this.width=void 0===t?100:t,this.height=void 0===s?100:s}static newFromXY(i,t,s,e){return void 0===i&&(i=0),void 0===t&&(t=0),new Box(new Point(i,t),s,e)}}class Range{constructor(i,t){i>t?(this.min=t,this.max=i):(this.min=i,this.max=t)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(i){void 0===i&&(i={}),"allowableOptions"in i||(i.allowableOptions={});for(const t in this.optionsAllowed)i.allowableOptions[t]=this.optionsAllowed[t];let t=i.allowableOptions;delete i.allowableOptions;for(const s in i)s in t?this[s]=i[s]:console.log("ERROR: Ignoring option: ",s);for(const i in t)void 0===this[i]&&void 0!==t[i]&&(this[i]=t[i])}}class TangleElement extends TangleBase{constructor(i,t,s){super(),this.g=i,this.center=null==t?Point(0,0):t,this.poly=[],this.optionsAllowed={debug:0,fillColor:0,strokeColor:0},this.loadOptions(s)}addVertex(i){this.poly.push(createVector(i.x,i.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(i,t,s){super(),this.width=i,this.height=t,this.g=createGraphics(i,t),this.gridPoints=[],this.optionsAllowed={debug:0,background:void 0,gridSpacing:void 0,gridXSpacing:40,gridYSpacing:40,gridVary:void 0,gridXVary:void 0,gridYVary:void 0,polys:[],avoidCollisions:!0,maskPoly:[],addStrings:!0},this.loadOptions(s),void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.02*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.02*this.gridYSpacing)}buildGridPoints(){for(let i=-this.gridYSpacing/2;i<this.height+this.gridYSpacing;i+=this.gridYSpacing){let t=[];for(let s=-this.gridXSpacing/2;s<this.width+this.gridXSpacing;s+=this.gridXSpacing)t.push(new Point(random(s-this.gridXVary,s+this.gridXVary),random(i-this.gridYVary,i+this.gridYVary)));this.gridPoints.push(t)}}grid(){0===this.gridPoints.length&&this.buildGridPoints();for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++){let s=this.gridPoints[i][t+1];void 0!==s&&this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y),void 0!==this.gridPoints[i+1]&&(s=this.gridPoints[i+1][t],this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y))}}collisionTest(i){if(!this.avoidCollisions)return!1;for(let t=0;t<this.polys.length;++t)if(collidePolyPoly(i,this.polys[t],!0))return!0;return!1}paste(i){image(this.g,i.x,i.y)}applyMask(){if(this.maskPoly.length<1)return;let i,t=createGraphics(this.width,this.height);t.noStroke(),t.fill(255,255,255,255),t.beginShape();for(let i=0;i<this.maskPoly.length;i++)t.vertex(this.maskPoly[i].x,this.maskPoly[i].y);if(t.endShape(CLOSE),(i=this.g.get()).mask(t.get()),this.g=createGraphics(this.width,this.height),this.g.image(i,0,0),this.addStrings){this.g.stroke(0),this.g.fill(0,0,0,0),this.g.beginShape();for(let i=0;i<this.maskPoly.length;i++)this.g.vertex(this.maskPoly[i].x,this.maskPoly[i].y);this.g.endShape(CLOSE)}}}class Dot extends TangleElement{constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={spacing:400,size:3},super(i,t,s),this.spacing=Math.max(100,this.spacing);let e=TWO_PI/8;for(let i=0;i<TWO_PI;i+=e)this.addVertex(new Polar(this.spacing/100*this.size,i).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:Aah.tipType.gap,size:100},super(i,t,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,n=this.rotate?random(0,e):0;for(let i=0;i<TWO_PI-e/2;i+=e){let t=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(i+n,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(s,t.a).toPointCenter(this.center),stop:t.toPointCenter(this.center),tipCenter:new Polar(t.r*(this.tipDistancePercent/100),t.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(h);let o=Math.max(t.r,t.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(o+5*s,t.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*t.r,t.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(i=>{this.g.line(i.start.x,i.start.y,i.stop.x,i.stop.y),this.g.circle(i.tipCenter.x,i.tipCenter.y,i.tipDiameter)})}}class Aahs extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={plan:Aahs.plans.zentangle},s.plan=void 0===s.plan?Aahs.plans.zentangle:s.plan,super(i,t,s),void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let i=0,t=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const e=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;i<e;){let h=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),o={debug:this.debug,size:randomGaussian(s,n)};void 0!==this.plan.aah.armCount&&(o.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(o.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(o.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(o.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(o.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(o.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(o.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(o.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(o.strokeColor=this.plan.aah.strokeColor);const r=new Aah(this.g,h,o),a=r.getPoly();if(this.collisionTest(a)){if(++t,t>3*e)break}else this.polys.push(a),r.draw(),++i}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const i=void 0===this.plan.dot.size?3:this.plan.dot.size,t=!isNaN(i),s=2*(t?i:i.max),e=this.width/s*(this.height/s);for(let s=0;s<e;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let e={debug:this.debug,size:t?i:i.rand()};void 0!==this.plan.dot.spacing&&(e.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(e.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(e.strokeColor=this.plan.dot.strokeColor);const n=new Dot(this.g,s,e),h=n.getPoly();this.collisionTest(h)||(this.polys.push(h),n.draw())}}this.applyMask()}}class BoxSpiralElement extends TangleElement{constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={divisions:4,nw:void 0,ne:void 0,se:void 0,sw:void 0,rotation:"ccw",size:50,startCorner:"nw",interior:!1,rotate:void 0},"fillColor"in s||(s.fillColor=color(0,0,0,0)),super(i,t,s),this.divisions=Entanglement.getInt(this.divisions),this.divisions=Math.max(this.interior?3:2,this.divisions),"random"===this.rotation&&(this.rotation=["cw","ccw"][Math.floor(random(0,2))]),"random"===this.startCorner&&(this.startCorner=["nw","ne","se","sw"][Math.floor(random(0,4))]),void 0===this.nw&&(this.nw=new Point(t.x-this.size/2,t.y-this.size/2)),void 0===this.ne&&(this.ne=new Point(t.x+this.size/2,t.y-this.size/2)),void 0===this.se&&(this.se=new Point(t.x+this.size/2,t.y+this.size/2)),void 0===this.sw&&(this.sw=new Point(t.x-this.size/2,t.y+this.size/2)),void 0!==this.rotate){const i=Entanglement.getValue(this.rotate);this.nw.rotate(i,this.center),this.ne.rotate(i,this.center),this.se.rotate(i,this.center),this.sw.rotate(i,this.center)}this.addVertex(this.nw),this.addVertex(this.ne),this.addVertex(this.se),this.addVertex(this.sw),this.pointPool=this._pointPool()}static newFromCoordinates(i,t,s,e,n,h){return void 0===h&&(h={}),h.nw=t,h.ne=s,h.se=e,h.sw=n,new BoxSpiralElement(i,new Point((t.x+s.x+e.x+n.x)/4,(t.y+s.y+e.y+n.y)/4),h)}draw(){this.g.noStroke(),this.g.fill(this.fillColor),this.g.beginShape(),this.g.vertex(this.nw.x,this.nw.y),this.g.vertex(this.ne.x,this.ne.y),this.g.vertex(this.se.x,this.se.y),this.g.vertex(this.sw.x,this.sw.y),this.g.endShape(CLOSE),this.g.stroke(this.strokeColor),this.current=this._firstPoint();let i=0;for(;;){const t=this._nextPoint();if(void 0===t)break;if(this.g.line(this.pointPool[this.current].x,this.pointPool[this.current].y,this.pointPool[t].x,this.pointPool[t].y),this.current=t,++i>5*this.divisions){console.log("BoxSpiralElement - runaway spiral?");break}}}_pointPool(){const i=new Line(this.nw,this.sw).divide(this.divisions),t=new Line(this.ne,this.se).divide(this.divisions),s=new Line(this.nw,this.ne).divide(this.divisions),e=new Line(this.sw,this.se).divide(this.divisions);let n=[],h=[];for(let o=0;o<=this.divisions;o++)n.push(new Line(s[o],e[o])),h.push(new Line(i[o],t[o]));let o=[];for(let i=0;i<=this.divisions;i++)for(let t=0;t<=this.divisions;t++)o.push(h[i].intersection(n[t]));return o}_nextDirection(){this.direction=this.direction+("ccw"===this.rotation?1:-1)%4}_firstPoint(){switch(this.direction=4*this.divisions,"cw"===this.rotation&&this.direction++,this.current=this.interior?this.divisions+2:0,this.step=this.interior?2:0,this.levelCount=3,this.startCorner){case"ne":this.current=this.interior?2*this.divisions:this.divisions,this.direction+=3;break;case"se":this.current=this.interior?Math.pow(this.divisions,2)+this.divisions-2:Math.pow(this.divisions+1,2)-1,this.direction+=2;break;case"sw":this.current=this.interior?Math.pow(this.divisions,2):this.divisions*(this.divisions+1),this.direction+=1}return this.current}_nextPoint(){let i;const t=this.divisions-this.step;if(0===t)return i;switch(this.direction%4){case 0:i=this.current+t*(this.divisions+1);break;case 1:i=this.current+t;break;case 2:i=this.current-t*(this.divisions+1);break;case 3:i=this.current-t}return 0==--this.levelCount&&(++this.step,this.levelCount=2),this._nextDirection(),i}}class BoxSpiral extends Tangle{constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={size:50,desiredCount:void 0,divisions:void 0,rotation:void 0,startCorner:void 0,rotate:new Range(0,90)},super(i,t,s),void 0===this.desiredCount){const i=isNaN(this.size)?this.size.min:this.size;this.desiredCount=this.width/i*this.height/i*10}for(let i=0;i<this.desiredCount;i++){let i={size:Entanglement.getInt(this.size),fillColor:this.background};this.divisions&&(i.divisions=this.divisions),this.rotation&&(i.rotation=this.rotation),this.rotate&&(i.rotate=this.rotate),this.startCorner&&(i.startCorner=this.startCorner);new BoxSpiralElement(this.g,new Point(random(0,this.width),random(0,this.height)),i).draw()}this.applyMask()}}class Ambler extends Tangle{constructor(i,t,s){void 0===s&&(s={}),super(i,t,s),this.buildGridPoints();const e=["nw","sw","se","ne"];let n=0,h=n+1;for(let i=0;i<this.gridPoints.length-1;i++){for(let t=0;t<this.gridPoints[i].length-1;t++){const s=this.gridPoints[i][t],h=this.gridPoints[i][t+1],o=this.gridPoints[i+1][t+1],r=this.gridPoints[i+1][t];BoxSpiralElement.newFromCoordinates(this.g,s,h,o,r,{startCorner:e[n%4],divisions:6,interior:!0}).draw(),n++}n=h++}this.grid(),this.applyMask()}}class ZentangleArea extends TangleBase{constructor(i,t,s){super(),this.origin=i,this.tangle=t,void 0===s&&(s={}),s.allowableOptions={},this.loadOptions(s)}}class Zentangle extends TangleBase{constructor(i,t,s){super(),void 0===s&&(s={}),s.allowableOptions={background:255,borderSize:20},this.loadOptions(s),this.width=i,this.height=i,this.shape=void 0===t?"square":t,"triangle"===this.shape&&(this.height*=.87),this.g=createGraphics(this.width,this.height);let e=new Point(this.width/2,this.height/2);switch(this.shape){case"circle":this.edgePoly=[];for(let i=0;i<360;i++)this.edgePoly.push(new Polar(this.width/2-1,radians(i)).toPointCenter(e));this.borderPoly=[];for(let i=0;i<360;i++)this.borderPoly.push(new Polar(this.width/2-this.borderSize,radians(i)).toPointCenter(e).vary(1));break;case"triangle":e=new Point(this.width/2,2*this.height/3),this.edgePoly=[new Point(0,this.height),new Point(this.width/2,0),new Point(this.width,this.height)];const i=2*this.height/3-2*this.borderSize;this.borderPoly=this._createBorderPolyFromLines([new Polar(i,radians(270)).toPointCenter(e),new Polar(i,radians(30)).toPointCenter(e),new Polar(i,radians(150)).toPointCenter(e)]);break;default:this.edgePoly=[new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)],this.borderPoly=this._createBorderPolyFromLines([new Point(this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.height-this.borderSize),new Point(this.borderSize,this.height-this.borderSize)])}this.areas=[],createCanvas(this.width,this.height),background(this.background)}addArea(i,t,s){const e=new ZentangleArea(i,t,s);this.areas.push(e),this.g.image(e.tangle.g,e.origin.x,e.origin.y)}draw(){let i,t=createGraphics(this.width,this.height);t.noStroke(),t.fill(255,255,255,0),t.beginShape();for(let i=0;i<this.edgePoly.length;i++)t.vertex(this.edgePoly[i].x,this.edgePoly[i].y);t.endShape(CLOSE),t.fill(255,255,255,255),t.beginShape();for(let i=0;i<this.borderPoly.length;i++)t.vertex(this.borderPoly[i].x,this.borderPoly[i].y);t.endShape(CLOSE),(i=this.g.get()).mask(t.get()),image(i,0,0),stroke(0),fill(255,255,255,0),beginShape();for(let i=0;i<this.borderPoly.length;i++)vertex(this.borderPoly[i].x,this.borderPoly[i].y);endShape(CLOSE),beginShape();for(let i=0;i<this.edgePoly.length;i++)vertex(this.edgePoly[i].x,this.edgePoly[i].y);endShape(CLOSE)}_createBorderPolyFromLines(i){let t=[];for(let s=0;s<i.length;s++){let e=s+1;e===i.length&&(e=0),t=t.concat(new Line(i[s],i[e]).handDrawn())}return t}}
