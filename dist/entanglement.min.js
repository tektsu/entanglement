class Entanglement{static version="0.0.6";static getValue(i){let t=i;return isNaN(i)&&(t=i.rand()),t}static getInt(i){let t=i;return isNaN(i)&&(t=random(i.min,i.max+1)),Math.floor(t)}}class Point{constructor(i,t){this.x=i,this.y=t}add(i){this.x+=i.x,this.y+=i.y}rotate(i,t){const s=radians(i),e=this.x-t.x,n=this.y-t.y;this.x=e*cos(s)-n*sin(s)+t.x,this.y=e*sin(s)+n*cos(s)+t.y}vary(i){return this.x+=random(-i,i),this.y+=random(-i,i),this}}class Polar{constructor(i,t){this.r=i,this.a=t}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(i){let t=this.toPoint();return t.add(i),t}}class Line{constructor(i,t){this.begin=i,this.end=t}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(i){let t=[this.begin];const s=this.begin.x-this.end.x,e=this.begin.y-this.end.y;for(let n=1;n<=i;n++)t.push(new Point(this.begin.x-n*s/i,this.begin.y-n*e/i));return t}handDrawn(i,t){if(void 0===i&&(i=Math.floor(this.length()/6)),0===i)return[this.begin,this.end];void 0===t&&(t=1);let s=[];const e=this.divide(i);for(let i=0;i<e.length;i++)0===i||i===e.length-1?s.push(e[i]):s.push(e[i].vary(t));return s}intersection(i){const t=(i.end.y-i.begin.y)*(this.end.x-this.begin.x)-(i.end.x-i.begin.x)*(this.end.y-this.begin.y);if(0==t)return;const s=this.begin.y-i.begin.y,e=this.begin.x-i.begin.x,n=((i.end.x-i.begin.x)*s-(i.end.y-i.begin.y)*e)/t,h=this.begin.x+n*(this.end.x-this.begin.x),o=this.begin.y+n*(this.end.y-this.begin.y);return new Point(h,o)}}class Polygon{constructor(i){this.boundingRectangle=void 0,this.vertices=[],void 0!==i&&(this.vertices=i)}addVertex(i){this.vertices.push(i),this.boundingRectangle=void 0}getBoundingRectangle(){if(void 0===this.boundingRectangle){let i=this.vertices[0].x,t=this.vertices[0].y,s=i,e=t;for(let n=1;n<this.vertices.length;n++)this.vertices[n].x<i&&(i=this.vertices[n].x),this.vertices[n].y<t&&(t=this.vertices[n].y),this.vertices[n].x>s&&(s=this.vertices[n].x),this.vertices[n].y>e&&(e=this.vertices[n].y);this.boundingRectangle=new Polygon([new Point(i,t),new Point(s,t),new Point(s,e),new Point(i,e)])}return this.boundingRectangle}getCenter(){return this.getBoundingRectangle(),new Point((this.boundingRectangle.vertices[0].x+this.boundingRectangle.vertices[1].x)/2,(this.boundingRectangle.vertices[0].y+this.boundingRectangle.vertices[3].y)/2)}getOrigin(){return this.getBoundingRectangle(),this.boundingRectangle.vertices[0]}getWidth(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].x-this.boundingRectangle.vertices[0].x)}getHeight(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].y-this.boundingRectangle.vertices[0].y)}rotate(i,t){void 0===t&&(t=this.getCenter());for(let s=0;s<this.vertices.length;s++)this.vertices[s].rotate(i,t);this.boundingRectangle=void 0}copy(){const i=new Polygon;for(let t=0;t<this.vertices.length;t++)i.addVertex(new Point(this.vertices[t].x,this.vertices[t].y));return i}}class Range{constructor(i,t){i>t?(this.min=t,this.max=i):(this.min=i,this.max=t)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(i){void 0===i&&(i={}),"allowableOptions"in i||(i.allowableOptions={});for(const t in this.optionsAllowed)i.allowableOptions[t]=this.optionsAllowed[t];let t=i.allowableOptions;delete i.allowableOptions;for(const s in i)s in t?this[s]=i[s]:console.log("ERROR: Ignoring option: ",s);for(const i in t)void 0===this[i]&&void 0!==t[i]&&(this[i]=t[i])}}class TangleElement extends TangleBase{constructor(i,t,s){super(),this.g=i,this.center=null==t?Point(0,0):t,this.poly=[],this.optionsAllowed={debug:0,fillColor:0,strokeColor:0},this.loadOptions(s)}addVertex(i){this.poly.push(createVector(i.x,i.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(i,t){super(),this.maskPoly=i,Array.isArray(i)&&(this.maskPoly=new Polygon(i)),this.build=function(){},this.optionsAllowed={debug:0,background:void 0,polys:[],avoidCollisions:!0,addStrings:!0,ignoreMask:!1,tangleRotate:0},this.loadOptions(t);const s=this.maskPoly.getBoundingRectangle().copy();if(this.origin=s.getOrigin(),this.width=s.getWidth(),this.height=s.getHeight(),this.tangleRotate){let i=this.origin.x,t=this.origin.y,e=i+this.width,n=t+this.height;s.rotate(this.tangleRotate);const h=s.getOrigin(),o=s.getWidth(),r=s.getHeight();i=Math.floor(Math.min(i,h.x)),t=Math.floor(Math.min(t,h.y)),e=Math.ceil(Math.max(e,h.x+o)),n=Math.ceil(Math.max(n,h.y+r)),this.origin=new Point(i,t),this.width=e-i,this.height=n-t}if(this.g=createGraphics(this.width,this.height),this.tangleRotate){const i=radians(this.tangleRotate),t=this.width/2,s=this.height/2,e=Math.floor(t-(t*cos(i)-s*sin(i))),n=Math.floor(s-(t*sin(i)+s*cos(i)));this.g.translate(e,n),this.g.rotate(i)}void 0!==this.background&&this.g.background(this.background)}collisionTest(i){if(!this.avoidCollisions)return!1;for(let t=0;t<this.polys.length;++t)if(collidePolyPoly(i,this.polys[t],!0))return!0;return!1}paste(i){image(this.g,i.x,i.y)}applyMask(){if(this.ignoreMask)return;let i,t=createGraphics(this.width,this.height);t.noStroke(),t.fill(255,255,255,255),t.beginShape();for(let i=0;i<this.maskPoly.vertices.length;i++)t.vertex(this.maskPoly.vertices[i].x-this.origin.x,this.maskPoly.vertices[i].y-this.origin.y);if(t.endShape(CLOSE),(i=this.g.get()).mask(t.get()),this.g=createGraphics(this.width,this.height),this.g.image(i,0,0),this.addStrings){this.g.stroke(0),this.g.fill(0,0,0,0),this.g.beginShape();for(let i=0;i<this.maskPoly.vertices.length;i++)this.g.vertex(this.maskPoly.vertices[i].x-this.origin.x,this.maskPoly.vertices[i].y-this.origin.y);this.g.endShape(CLOSE)}}execute(){this.build(),this.ignoreMask||this.applyMask()}}class GridTangle extends Tangle{constructor(i,t){void 0===t&&(t={}),void 0===t.allowableOptions&&(t.allowableOptions={}),t.allowableOptions={...t.allowableOptions,gridShow:!1,gridSpacing:void 0,gridDivisions:void 0,gridXDivisions:void 0,gridYDivisions:void 0,gridXSpacing:40,gridYSpacing:40,gridXSpacingMode:"static",gridYSpacingMode:"static",gridVary:void 0,gridXVary:void 0,gridYVary:void 0},super(i,t),this.gridPoints=[],this.gridMeta=[],this.gridVariation=[],void 0!==this.gridSpacing&&("object"==typeof this.gridSpacing?(this.gridXSpacing=new Range(this.gridSpacing.min,this.gridSpacing.max),this.gridYSpacing=new Range(this.gridSpacing.min,this.gridSpacing.max)):this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.02*("object"==typeof this.gridXSpacing?this.gridXSpacing.min:this.gridXSpacing)),void 0===this.gridYVary&&(this.gridYVary=.02*("object"==typeof this.gridYSpacing?this.gridYSpacing.min:this.gridYSpacing)),void 0!==this.gridDivisions&&(this.gridXDivisions=this.gridYDivisions=this.gridDivisions)}_updateMeta(i,t){if(t>0){if("number"==typeof this.gridXSpacing)this.gridMeta[i][t].x=this.gridMeta[i][t-1].x+this.gridXSpacing;else switch(this.gridXSpacingMode){case"random":this.gridMeta[i][t].x=this.gridMeta[i][t-1].x+this.gridXSpacing.rand();break;case"linear":this.gridMeta[i][t].x=this.gridMeta[i][t-1].x+this.gridXSpacing.min+t/this.maxCols*(this.gridXSpacing.max-this.gridXSpacing.min);break;default:this.gridMeta[i][t].x=this.gridMeta[i][t-1].x+this.gridXSpacing.min}this.gridMeta[i][t].y=this.gridMeta[i][t-1].y}else if(i>0)if("number"==typeof this.gridYSpacing)this.gridMeta[i][t].y=this.gridMeta[i-1][t].y+this.gridYSpacing;else switch(this.gridYSpacingMode){case"random":this.gridMeta[i][t].y=this.gridMeta[i-1][t].y+this.gridYSpacing.rand();break;case"linear":this.gridMeta[i][t].y=this.gridMeta[i-1][t].y+this.gridYSpacing.min+i/this.maxRows*(this.gridYSpacing.max-this.gridYSpacing.min);break;default:this.gridMeta[i][t].y=this.gridMeta[i-1][t].y+this.gridYSpacing.min}}buildGridPoints(){const i="object"==typeof this.gridXSpacing?this.gridXSpacing.min:this.gridXSpacing,t="object"==typeof this.gridYSpacing?this.gridYSpacing.min:this.gridYSpacing;this.maxCols=this.width/i+2,this.maxRows=this.height/t+2,this.gridPoints=[],this.gridMeta=[];for(let s=0;s<this.maxRows;s++){this.gridPoints[s]=[],this.gridMeta[s]=[];for(let e=0;e<this.maxCols;e++)this.gridMeta[s][e]={x:-i/2,y:-t/2},this._updateMeta(s,e),this.gridPoints[s][e]=new Point(random(this.gridMeta[s][e].x-this.gridXVary,this.gridMeta[s][e].x+this.gridXVary),random(this.gridMeta[s][e].y-this.gridYVary,this.gridMeta[s][e].y+this.gridYVary))}}showGrid(){0===this.gridPoints.length&&this.buildGridPoints();for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++){let s=this.gridPoints[i][t+1];void 0!==s&&this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y),void 0!==this.gridPoints[i+1]&&(s=this.gridPoints[i+1][t],this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y))}}execute(){this.buildGridPoints(),this.build(),this.gridShow&&this.showGrid(),this.ignoreMask||this.applyMask()}}class DotElement extends TangleElement{constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={spacing:400,size:3},super(i,t,s),this.spacing=Math.max(100,this.spacing);let e=TWO_PI/8;for(let i=0;i<TWO_PI;i+=e)this.addVertex(new Polar(this.spacing/100*this.size,i).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class AahElement extends TangleElement{static tipType={gap:"gap"};constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:AahElement.tipType.gap,size:100},super(i,t,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,n=this.rotate?random(0,e):0;for(let i=0;i<TWO_PI-e/2;i+=e){let t=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(i+n,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(s,t.a).toPointCenter(this.center),stop:t.toPointCenter(this.center),tipCenter:new Polar(t.r*(this.tipDistancePercent/100),t.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===AahElement.tipType.gap?s:10:this.tipDiameter};this.arms.push(h);let o=Math.max(t.r,t.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(o+5*s,t.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*t.r,t.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(i=>{this.g.line(i.start.x,i.start.y,i.stop.x,i.stop.y),this.g.circle(i.tipCenter.x,i.tipCenter.y,i.tipDiameter)})}}class Aah extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(i,t){void 0===t&&(t={}),t.allowableOptions={plan:Aah.plans.zentangle},t.plan=void 0===t.plan?Aah.plans.zentangle:t.plan,super(i,t),this.build=function(){if(void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let i=0,t=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const e=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;i<e;){let h=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),o={debug:this.debug,size:randomGaussian(s,n)};void 0!==this.plan.aah.armCount&&(o.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(o.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(o.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(o.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(o.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(o.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(o.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(o.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(o.strokeColor=this.plan.aah.strokeColor);const r=new AahElement(this.g,h,o),a=r.getPoly();if(this.collisionTest(a)){if(++t,t>3*e)break}else this.polys.push(a),r.draw(),++i}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const i=void 0===this.plan.dot.size?3:this.plan.dot.size,t=!isNaN(i),s=2*(t?i:i.max),e=this.width/s*(this.height/s);for(let s=0;s<e;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let e={debug:this.debug,size:t?i:i.rand()};void 0!==this.plan.dot.spacing&&(e.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(e.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(e.strokeColor=this.plan.dot.strokeColor);const n=new DotElement(this.g,s,e),h=n.getPoly();this.collisionTest(h)||(this.polys.push(h),n.draw())}}},this.execute()}}class BoxSpiralElement extends TangleElement{constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={divisions:4,nw:void 0,ne:void 0,se:void 0,sw:void 0,rotation:"ccw",size:50,startCorner:"nw",interior:!1,rotate:void 0},"fillColor"in s||(s.fillColor=color(0,0,0,0)),super(i,t,s),this.divisions=Entanglement.getInt(this.divisions),this.divisions=Math.max(this.interior?3:2,this.divisions),"random"===this.rotation&&(this.rotation=["cw","ccw"][Math.floor(random(0,2))]),"random"===this.startCorner&&(this.startCorner=["nw","ne","se","sw"][Math.floor(random(0,4))]),void 0===this.nw&&(this.nw=new Point(t.x-this.size/2,t.y-this.size/2)),void 0===this.ne&&(this.ne=new Point(t.x+this.size/2,t.y-this.size/2)),void 0===this.se&&(this.se=new Point(t.x+this.size/2,t.y+this.size/2)),void 0===this.sw&&(this.sw=new Point(t.x-this.size/2,t.y+this.size/2)),void 0!==this.rotate){const i=Entanglement.getValue(this.rotate);this.nw.rotate(i,this.center),this.ne.rotate(i,this.center),this.se.rotate(i,this.center),this.sw.rotate(i,this.center)}this.addVertex(this.nw),this.addVertex(this.ne),this.addVertex(this.se),this.addVertex(this.sw),this.pointPool=this._pointPool()}static newFromCoordinates(i,t,s,e,n,h){return void 0===h&&(h={}),h.nw=t,h.ne=s,h.se=e,h.sw=n,new BoxSpiralElement(i,new Point((t.x+s.x+e.x+n.x)/4,(t.y+s.y+e.y+n.y)/4),h)}draw(){this.g.noStroke(),this.g.fill(this.fillColor),this.g.beginShape(),this.g.vertex(this.nw.x,this.nw.y),this.g.vertex(this.ne.x,this.ne.y),this.g.vertex(this.se.x,this.se.y),this.g.vertex(this.sw.x,this.sw.y),this.g.endShape(CLOSE),this.g.stroke(this.strokeColor),this.current=this._firstPoint();let i=0;for(;;){const t=this._nextPoint();if(void 0===t)break;if(this.g.line(this.pointPool[this.current].x,this.pointPool[this.current].y,this.pointPool[t].x,this.pointPool[t].y),this.current=t,++i>5*this.divisions){console.log("BoxSpiralElement - runaway spiral?");break}}}_pointPool(){const i=new Line(this.nw,this.sw).divide(this.divisions),t=new Line(this.ne,this.se).divide(this.divisions),s=new Line(this.nw,this.ne).divide(this.divisions),e=new Line(this.sw,this.se).divide(this.divisions);let n=[],h=[];for(let o=0;o<=this.divisions;o++)n.push(new Line(s[o],e[o])),h.push(new Line(i[o],t[o]));let o=[];for(let i=0;i<=this.divisions;i++)for(let t=0;t<=this.divisions;t++)o.push(h[i].intersection(n[t]));return o}_nextDirection(){this.direction=this.direction+("ccw"===this.rotation?1:-1)%4}_firstPoint(){switch(this.direction=4*this.divisions,"cw"===this.rotation&&this.direction++,this.current=this.interior?this.divisions+2:0,this.step=this.interior?2:0,this.levelCount=3,this.startCorner){case"ne":this.current=this.interior?2*this.divisions:this.divisions,this.direction+=3;break;case"se":this.current=this.interior?Math.pow(this.divisions,2)+this.divisions-2:Math.pow(this.divisions+1,2)-1,this.direction+=2;break;case"sw":this.current=this.interior?Math.pow(this.divisions,2):this.divisions*(this.divisions+1),this.direction+=1}return this.current}_nextPoint(){let i;const t=this.divisions-this.step;if(0===t)return i;switch(this.direction%4){case 0:i=this.current+t*(this.divisions+1);break;case 1:i=this.current+t;break;case 2:i=this.current-t*(this.divisions+1);break;case 3:i=this.current-t}return 0==--this.levelCount&&(++this.step,this.levelCount=2),this._nextDirection(),i}}class BoxSpirals extends Tangle{constructor(i,t){void 0===t&&(t={}),t.allowableOptions={size:50,desiredCount:void 0,divisions:void 0,rotation:void 0,startCorner:void 0,rotate:new Range(0,90)},super(i,t),this.build=function(){if(void 0===this.desiredCount){const i=isNaN(this.size)?this.size.min:this.size;this.desiredCount=Math.floor(this.width/i*this.height/i*10)}for(let i=0;i<this.desiredCount;i++){let i={size:Entanglement.getInt(this.size),fillColor:this.background};this.divisions&&(i.divisions=this.divisions),this.rotation&&(i.rotation=this.rotation),this.rotate&&(i.rotate=this.rotate),this.startCorner&&(i.startCorner=this.startCorner);new BoxSpiralElement(this.g,new Point(random(0,this.width),random(0,this.height)),i).draw()}},this.execute()}}class Ambler extends GridTangle{constructor(i,t){void 0===t&&(t={}),void 0===t.gridShow&&(t.gridShow=!0),super(i,t),this.build=function(){const i=["nw","sw","se","ne"];let t=0,s=t+1;for(let e=0;e<this.gridPoints.length-1;e++){for(let s=0;s<this.gridPoints[e].length-1;s++){const n=this.gridPoints[e][s],h=this.gridPoints[e][s+1],o=this.gridPoints[e+1][s+1],r=this.gridPoints[e+1][s];BoxSpiralElement.newFromCoordinates(this.g,n,h,o,r,{startCorner:i[t%4],divisions:6,interior:!0}).draw(),t++}t=s++}},this.execute()}}class Emingle extends GridTangle{constructor(i,t){void 0===t&&(t={}),void 0===t.gridShow&&(t.gridShow=!0),t.allowableOptions={startCorner:"nw"},super(i,t),this.build=function(){const i=["nw","sw","se","ne"];"random"===this.startCorner&&(this.startCorner=i[Math.floor(random(0,4))]);for(let i=0;i<this.gridPoints.length-1;i++)for(let t=0;t<this.gridPoints[i].length-1;t++){const s=this.gridPoints[i][t],e=this.gridPoints[i][t+1],n=this.gridPoints[i+1][t+1],h=this.gridPoints[i+1][t];BoxSpiralElement.newFromCoordinates(this.g,s,e,n,h,{startCorner:this.startCorner,divisions:6,interior:!0}).draw()}},this.execute()}}class Huggins extends GridTangle{constructor(i,t){void 0===t&&(t={}),t.gridShow=!1,t.allowableOptions={holeDiameter:"proportional",holeFillColor:"black",holesShow:!0,curve:5},super(i,t),this.build=function(){"proportional"===this.holeDiameter&&(this.holeDiameter=Math.min("object"==typeof this.gridXSpacing?this.gridXSpacing.min:this.gridXSpacing,"object"==typeof this.gridYSpacing?this.gridYSpacing.min:this.gridYSpacing)/4);const i=this.holeDiameter/2,t=this.curve*i;this.g.curveTightness(0);let s=[];for(let e=0;e<this.gridPoints.length;e++){let n=[];for(let s=0;s<this.gridPoints[e].length;s++){let h=[];h.push(new Polar(i,radians(225)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(315)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(45)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(135)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(225)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(315)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(45)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(135)).toPointCenter(this.gridPoints[e][s])),n.push(h)}s.push(n)}this.g.fill(0,0,0,0);let e=0,n=1;for(let i=0;i<this.gridPoints.length;i++){for(let t=0;t<this.gridPoints[i].length-1;t++){let n=s[i][t][7],h=s[i][t][0],o=s[i][t+1][1],r=s[i][t+1][6];e++%2&&(n=s[i][t][4],h=s[i][t][3],o=s[i][t+1][2],r=s[i][t+1][5]),this.g.curve(n.x,n.y,h.x,h.y,o.x,o.y,r.x,r.y)}e=n++}e=0,n=1;for(let i=0;i<this.gridPoints.length-1;i++){for(let t=0;t<this.gridPoints[i].length;t++){let n=s[i][t][4],h=s[i][t][1],o=s[i+1][t][2],r=s[i+1][t][7];e++%2&&(n=s[i][t][5],h=s[i][t][0],o=s[i+1][t][3],r=s[i+1][t][6]),this.g.curve(n.x,n.y,h.x,h.y,o.x,o.y,r.x,r.y)}e=n++}if(this.holesShow){this.g.fill(this.holeFillColor);for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++)this.g.circle(this.gridPoints[i][t].x,this.gridPoints[i][t].y,this.holeDiameter)}},this.execute()}}class W2 extends GridTangle{constructor(i,t){void 0===t&&(t={}),t.gridShow=!1,t.allowableOptions={holeSize:"proportional",holeFillColor:"black",holesShow:!0},super(i,t),this.build=function(){"proportional"===this.holeSize&&(this.holeSize=Math.min("object"==typeof this.gridXSpacing?this.gridXSpacing.min:this.gridXSpacing,"object"==typeof this.gridYSpacing?this.gridYSpacing.min:this.gridYSpacing)/4);const i=this.holeSize/2;let t=[];for(let s=0;s<this.gridPoints.length;s++){let e=[];for(let t=0;t<this.gridPoints[s].length;t++){let n=[];n.push(new Point(this.gridPoints[s][t].x-i,this.gridPoints[s][t].y-i)),n.push(new Point(this.gridPoints[s][t].x+i,this.gridPoints[s][t].y-i)),n.push(new Point(this.gridPoints[s][t].x+i,this.gridPoints[s][t].y+i)),n.push(new Point(this.gridPoints[s][t].x-i,this.gridPoints[s][t].y+i)),e.push(n)}t.push(e)}this.g.fill(0,0,0,0);let s=0,e=1;for(let i=0;i<this.gridPoints.length;i++){for(let e=0;e<this.gridPoints[i].length-1;e++){let n=t[i][e][1],h=t[i][e+1][0];s++%2&&(n=t[i][e][2],h=t[i][e+1][3]),this.g.line(n.x,n.y,h.x,h.y)}s=e++}s=0,e=1;for(let i=0;i<this.gridPoints.length-1;i++){for(let e=0;e<this.gridPoints[i].length;e++){let n=t[i][e][2],h=t[i+1][e][1];s++%2&&(n=t[i][e][3],h=t[i+1][e][0]),this.g.line(n.x,n.y,h.x,h.y)}s=e++}if(this.holesShow){this.g.fill(this.holeFillColor);for(let i=0;i<this.gridPoints.length;i++)for(let s=0;s<this.gridPoints[i].length;s++)this.g.rect(t[i][s][0].x,t[i][s][0].y,this.holeSize,this.holeSize)}},this.execute()}}class Zentangle extends TangleBase{constructor(i,t,s){super(),void 0===s&&(s={}),s.allowableOptions={background:255,borderSize:30},this.loadOptions(s),this.width=i,this.height=i,this.shape=void 0===t?"square":t,"triangle"===this.shape&&(this.height*=.87),this.g=createGraphics(this.width,this.height);let e=new Point(this.width/2,this.height/2);switch(this.shape){case"circle":this.edgePoly=new Polygon;for(let i=0;i<360;i++)this.edgePoly.addVertex(new Polar(this.width/2-1,radians(i)).toPointCenter(e));this.borderPoly=new Polygon;for(let i=0;i<360;i++)this.borderPoly.addVertex(new Polar(this.width/2-this.borderSize,radians(i)).toPointCenter(e).vary(1));break;case"triangle":e=new Point(this.width/2,2*this.height/3),this.edgePoly=new Polygon([new Point(0,this.height),new Point(this.width/2,0),new Point(this.width,this.height)]);const i=2*this.height/3-2*this.borderSize;this.borderPoly=this._createBorderPolyFromLines([new Polar(i,radians(270)).toPointCenter(e),new Polar(i,radians(30)).toPointCenter(e),new Polar(i,radians(150)).toPointCenter(e)]);break;default:this.edgePoly=new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)]),this.borderPoly=this._createBorderPolyFromLines([new Point(this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.height-this.borderSize),new Point(this.borderSize,this.height-this.borderSize)])}this.areas=[],createCanvas(this.width,this.height),background(this.background)}getFullMask(){return new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)])}addTangle(i){this.areas.push(i),this.g.image(i.g,i.origin.x,i.origin.y)}draw(){let i,t=createGraphics(this.width,this.height);t.noStroke(),t.fill(255,255,255,0),t.beginShape();for(let i=0;i<this.edgePoly.vertices.length;i++)t.vertex(this.edgePoly.vertices[i].x,this.edgePoly.vertices[i].y);t.endShape(CLOSE),t.fill(255,255,255,255),t.beginShape();for(let i=0;i<this.borderPoly.vertices.length;i++)t.vertex(this.borderPoly.vertices[i].x,this.borderPoly.vertices[i].y);t.endShape(CLOSE),(i=this.g.get()).mask(t.get()),image(i,0,0),stroke(0),fill(255,255,255,0),beginShape();for(let i=0;i<this.borderPoly.vertices.length;i++)vertex(this.borderPoly.vertices[i].x,this.borderPoly.vertices[i].y);endShape(CLOSE),beginShape();for(let i=0;i<this.edgePoly.vertices.length;i++)vertex(this.edgePoly.vertices[i].x,this.edgePoly.vertices[i].y);endShape(CLOSE)}_createBorderPolyFromLines(i){let t=new Polygon;for(let s=0;s<i.length;s++){let e=s+1;e===i.length&&(e=0);const n=new Line(i[s],i[e]).handDrawn();for(let i=0;i<n.length;i++)t.addVertex(n[i])}return t}}
