class Entanglement{static version="0.0.5";static getValue(t){let i=t;return isNaN(t)&&(i=t.rand()),i}static getInt(t){let i=t;return isNaN(t)&&(i=random(t.min,t.max+1)),Math.floor(i)}}class Point{constructor(t,i){this.x=t,this.y=i}add(t){this.x+=t.x,this.y+=t.y}rotate(t,i){const e=radians(t),s=this.x-i.x,n=this.y-i.y;this.x=s*cos(e)-n*sin(e)+i.x,this.y=s*sin(e)+n*cos(e)+i.y}vary(t){return this.x+=random(-t,t),this.y+=random(-t,t),this}}class Polar{constructor(t,i){this.r=t,this.a=i}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(t){let i=this.toPoint();return i.add(t),i}}class Line{constructor(t,i){this.begin=t,this.end=i}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(t){let i=[this.begin];const e=this.begin.x-this.end.x,s=this.begin.y-this.end.y;for(let n=1;n<=t;n++)i.push(new Point(this.begin.x-n*e/t,this.begin.y-n*s/t));return i}handDrawn(t,i){if(void 0===t&&(t=Math.floor(this.length()/6)),0===t)return[this.begin,this.end];void 0===i&&(i=1);let e=[];const s=this.divide(t);for(let t=0;t<s.length;t++)0===t||t===s.length-1?e.push(s[t]):e.push(s[t].vary(i));return e}intersection(t){const i=(t.end.y-t.begin.y)*(this.end.x-this.begin.x)-(t.end.x-t.begin.x)*(this.end.y-this.begin.y);if(0==i)return;const e=this.begin.y-t.begin.y,s=this.begin.x-t.begin.x,n=((t.end.x-t.begin.x)*e-(t.end.y-t.begin.y)*s)/i,h=this.begin.x+n*(this.end.x-this.begin.x),o=this.begin.y+n*(this.end.y-this.begin.y);return new Point(h,o)}}class Polygon{constructor(t){this.boundingRectangle=void 0,this.vertices=[],void 0!==t&&(this.vertices=t)}addVertex(t){this.vertices.push(t),this.boundingRectangle=void 0}getBoundingRectangle(){if(void 0===this.boundingRectangle){let t=this.vertices[0].x,i=this.vertices[0].y,e=t,s=i;for(let n=1;n<this.vertices.length;n++)this.vertices[n].x<t&&(t=this.vertices[n].x),this.vertices[n].y<i&&(i=this.vertices[n].y),this.vertices[n].x>e&&(e=this.vertices[n].x),this.vertices[n].y>s&&(s=this.vertices[n].y);this.boundingRectangle=new Polygon([new Point(t,i),new Point(e,i),new Point(e,s),new Point(t,s)])}return this.boundingRectangle}getCenter(){return this.getBoundingRectangle(),new Point((this.boundingRectangle.vertices[0].x+this.boundingRectangle.vertices[1].x)/2,(this.boundingRectangle.vertices[0].y+this.boundingRectangle.vertices[3].y)/2)}getOrigin(){return this.getBoundingRectangle(),this.boundingRectangle.vertices[0]}getWidth(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].x-this.boundingRectangle.vertices[0].x)}getHeight(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].y-this.boundingRectangle.vertices[0].y)}rotate(t,i){void 0===i&&(i=this.getCenter());for(let e=0;e<this.vertices.length;e++)this.vertices[e].rotate(t,i);this.boundingRectangle=void 0}copy(){const t=new Polygon;for(let i=0;i<this.vertices.length;i++)t.addVertex(new Point(this.vertices[i].x,this.vertices[i].y));return t}}class Range{constructor(t,i){t>i?(this.min=i,this.max=t):(this.min=t,this.max=i)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(t){void 0===t&&(t={}),"allowableOptions"in t||(t.allowableOptions={});for(const i in this.optionsAllowed)t.allowableOptions[i]=this.optionsAllowed[i];let i=t.allowableOptions;delete t.allowableOptions;for(const e in t)e in i?this[e]=t[e]:console.log("ERROR: Ignoring option: ",e);for(const t in i)void 0===this[t]&&void 0!==i[t]&&(this[t]=i[t])}}class TangleElement extends TangleBase{constructor(t,i,e){super(),this.g=t,this.center=null==i?Point(0,0):i,this.poly=[],this.optionsAllowed={debug:0,fillColor:0,strokeColor:0},this.loadOptions(e)}addVertex(t){this.poly.push(createVector(t.x,t.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(t,i){super(),this.maskPoly=t,Array.isArray(t)&&(this.maskPoly=new Polygon(t)),this.gridPoints=[],this.build=function(){},this.optionsAllowed={debug:0,background:void 0,grid:!1,gridShow:!1,gridSpacing:void 0,gridXSpacing:40,gridYSpacing:40,gridVary:void 0,gridXVary:void 0,gridYVary:void 0,polys:[],avoidCollisions:!0,addStrings:!0,ignoreMask:!1,tangleRotate:0},this.loadOptions(i);const e=this.maskPoly.getBoundingRectangle().copy();if(this.origin=e.getOrigin(),this.width=e.getWidth(),this.height=e.getHeight(),this.tangleRotate){let t=this.origin.x,i=this.origin.y,s=t+this.width,n=i+this.height;e.rotate(this.tangleRotate);const h=e.getOrigin(),o=e.getWidth(),r=e.getHeight();t=Math.floor(Math.min(t,h.x)),i=Math.floor(Math.min(i,h.y)),s=Math.ceil(Math.max(s,h.x+o)),n=Math.ceil(Math.max(n,h.y+r)),this.origin=new Point(t,i),this.width=s-t,this.height=n-i}if(this.g=createGraphics(this.width,this.height),this.tangleRotate){const t=radians(this.tangleRotate),i=this.width/2,e=this.height/2,s=Math.floor(i-(i*cos(t)-e*sin(t))),n=Math.floor(e-(i*sin(t)+e*cos(t)));this.g.translate(s,n),this.g.rotate(t)}void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.02*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.02*this.gridYSpacing)}buildGridPoints(){for(let t=-this.gridYSpacing/2;t<this.height+this.gridYSpacing;t+=this.gridYSpacing){let i=[];for(let e=-this.gridXSpacing/2;e<this.width+this.gridXSpacing;e+=this.gridXSpacing)i.push(new Point(random(e-this.gridXVary,e+this.gridXVary),random(t-this.gridYVary,t+this.gridYVary)));this.gridPoints.push(i)}}showGrid(){0===this.gridPoints.length&&this.buildGridPoints();for(let t=0;t<this.gridPoints.length;t++)for(let i=0;i<this.gridPoints[t].length;i++){let e=this.gridPoints[t][i+1];void 0!==e&&this.g.line(this.gridPoints[t][i].x,this.gridPoints[t][i].y,e.x,e.y),void 0!==this.gridPoints[t+1]&&(e=this.gridPoints[t+1][i],this.g.line(this.gridPoints[t][i].x,this.gridPoints[t][i].y,e.x,e.y))}}collisionTest(t){if(!this.avoidCollisions)return!1;for(let i=0;i<this.polys.length;++i)if(collidePolyPoly(t,this.polys[i],!0))return!0;return!1}paste(t){image(this.g,t.x,t.y)}applyMask(){if(this.ignoreMask)return;let t,i=createGraphics(this.width,this.height);i.noStroke(),i.fill(255,255,255,255),i.beginShape();for(let t=0;t<this.maskPoly.vertices.length;t++)i.vertex(this.maskPoly.vertices[t].x-this.origin.x,this.maskPoly.vertices[t].y-this.origin.y);if(i.endShape(CLOSE),(t=this.g.get()).mask(i.get()),this.g=createGraphics(this.width,this.height),this.g.image(t,0,0),this.addStrings){this.g.stroke(0),this.g.fill(0,0,0,0),this.g.beginShape();for(let t=0;t<this.maskPoly.vertices.length;t++)this.g.vertex(this.maskPoly.vertices[t].x-this.origin.x,this.maskPoly.vertices[t].y-this.origin.y);this.g.endShape(CLOSE)}}execute(){this.grid&&this.buildGridPoints(),this.build(),this.grid&&this.gridShow&&this.showGrid(),this.ignoreMask||this.applyMask()}}class DotElement extends TangleElement{constructor(t,i,e){void 0===e&&(e={}),e.allowableOptions={spacing:400,size:3},super(t,i,e),this.spacing=Math.max(100,this.spacing);let s=TWO_PI/8;for(let t=0;t<TWO_PI;t+=s)this.addVertex(new Polar(this.spacing/100*this.size,t).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class AahElement extends TangleElement{static tipType={gap:"gap"};constructor(t,i,e){void 0===e&&(e={}),e.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:AahElement.tipType.gap,size:100},super(t,i,e),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const s=TWO_PI/this.armCount,n=this.rotate?random(0,s):0;for(let t=0;t<TWO_PI-s/2;t+=s){let i=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(t+n,this.thetaSD*Math.PI/180));const e=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(e,i.a).toPointCenter(this.center),stop:i.toPointCenter(this.center),tipCenter:new Polar(i.r*(this.tipDistancePercent/100),i.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===AahElement.tipType.gap?e:10:this.tipDiameter};this.arms.push(h);let o=Math.max(i.r,i.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(o+5*e,i.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*i.r,i.a+s/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(t=>{this.g.line(t.start.x,t.start.y,t.stop.x,t.stop.y),this.g.circle(t.tipCenter.x,t.tipCenter.y,t.tipDiameter)})}}class Aah extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(t,i){void 0===i&&(i={}),i.allowableOptions={plan:Aah.plans.zentangle},i.plan=void 0===i.plan?Aah.plans.zentangle:i.plan,super(t,i),this.build=function(){if(void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let t=0,i=0;const e=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=e/6);const s=void 0===this.plan.aah.desiredCount?this.width/e*(this.height/e)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*e:this.plan.aah.sizeSDP;for(;t<s;){let h=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),o={debug:this.debug,size:randomGaussian(e,n)};void 0!==this.plan.aah.armCount&&(o.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(o.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(o.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(o.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(o.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(o.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(o.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(o.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(o.strokeColor=this.plan.aah.strokeColor);const r=new AahElement(this.g,h,o),a=r.getPoly();if(this.collisionTest(a)){if(++i,i>3*s)break}else this.polys.push(a),r.draw(),++t}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const t=void 0===this.plan.dot.size?3:this.plan.dot.size,i=!isNaN(t),e=2*(i?t:t.max),s=this.width/e*(this.height/e);for(let e=0;e<s;++e){const e=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let s={debug:this.debug,size:i?t:t.rand()};void 0!==this.plan.dot.spacing&&(s.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(s.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(s.strokeColor=this.plan.dot.strokeColor);const n=new DotElement(this.g,e,s),h=n.getPoly();this.collisionTest(h)||(this.polys.push(h),n.draw())}}},this.execute()}}class BoxSpiralElement extends TangleElement{constructor(t,i,e){if(void 0===e&&(e={}),e.allowableOptions={divisions:4,nw:void 0,ne:void 0,se:void 0,sw:void 0,rotation:"ccw",size:50,startCorner:"nw",interior:!1,rotate:void 0},"fillColor"in e||(e.fillColor=color(0,0,0,0)),super(t,i,e),this.divisions=Entanglement.getInt(this.divisions),this.divisions=Math.max(this.interior?3:2,this.divisions),"random"===this.rotation&&(this.rotation=["cw","ccw"][Math.floor(random(0,2))]),"random"===this.startCorner&&(this.startCorner=["nw","ne","se","sw"][Math.floor(random(0,4))]),void 0===this.nw&&(this.nw=new Point(i.x-this.size/2,i.y-this.size/2)),void 0===this.ne&&(this.ne=new Point(i.x+this.size/2,i.y-this.size/2)),void 0===this.se&&(this.se=new Point(i.x+this.size/2,i.y+this.size/2)),void 0===this.sw&&(this.sw=new Point(i.x-this.size/2,i.y+this.size/2)),void 0!==this.rotate){const t=Entanglement.getValue(this.rotate);this.nw.rotate(t,this.center),this.ne.rotate(t,this.center),this.se.rotate(t,this.center),this.sw.rotate(t,this.center)}this.addVertex(this.nw),this.addVertex(this.ne),this.addVertex(this.se),this.addVertex(this.sw),this.pointPool=this._pointPool()}static newFromCoordinates(t,i,e,s,n,h){return void 0===h&&(h={}),h.nw=i,h.ne=e,h.se=s,h.sw=n,new BoxSpiralElement(t,new Point((i.x+e.x+s.x+n.x)/4,(i.y+e.y+s.y+n.y)/4),h)}draw(){this.g.noStroke(),this.g.fill(this.fillColor),this.g.beginShape(),this.g.vertex(this.nw.x,this.nw.y),this.g.vertex(this.ne.x,this.ne.y),this.g.vertex(this.se.x,this.se.y),this.g.vertex(this.sw.x,this.sw.y),this.g.endShape(CLOSE),this.g.stroke(this.strokeColor),this.current=this._firstPoint();let t=0;for(;;){const i=this._nextPoint();if(void 0===i)break;if(this.g.line(this.pointPool[this.current].x,this.pointPool[this.current].y,this.pointPool[i].x,this.pointPool[i].y),this.current=i,++t>5*this.divisions){console.log("BoxSpiralElement - runaway spiral?");break}}}_pointPool(){const t=new Line(this.nw,this.sw).divide(this.divisions),i=new Line(this.ne,this.se).divide(this.divisions),e=new Line(this.nw,this.ne).divide(this.divisions),s=new Line(this.sw,this.se).divide(this.divisions);let n=[],h=[];for(let o=0;o<=this.divisions;o++)n.push(new Line(e[o],s[o])),h.push(new Line(t[o],i[o]));let o=[];for(let t=0;t<=this.divisions;t++)for(let i=0;i<=this.divisions;i++)o.push(h[t].intersection(n[i]));return o}_nextDirection(){this.direction=this.direction+("ccw"===this.rotation?1:-1)%4}_firstPoint(){switch(this.direction=4*this.divisions,"cw"===this.rotation&&this.direction++,this.current=this.interior?this.divisions+2:0,this.step=this.interior?2:0,this.levelCount=3,this.startCorner){case"ne":this.current=this.interior?2*this.divisions:this.divisions,this.direction+=3;break;case"se":this.current=this.interior?Math.pow(this.divisions,2)+this.divisions-2:Math.pow(this.divisions+1,2)-1,this.direction+=2;break;case"sw":this.current=this.interior?Math.pow(this.divisions,2):this.divisions*(this.divisions+1),this.direction+=1}return this.current}_nextPoint(){let t;const i=this.divisions-this.step;if(0===i)return t;switch(this.direction%4){case 0:t=this.current+i*(this.divisions+1);break;case 1:t=this.current+i;break;case 2:t=this.current-i*(this.divisions+1);break;case 3:t=this.current-i}return 0==--this.levelCount&&(++this.step,this.levelCount=2),this._nextDirection(),t}}class BoxSpirals extends Tangle{constructor(t,i){void 0===i&&(i={}),i.allowableOptions={size:50,desiredCount:void 0,divisions:void 0,rotation:void 0,startCorner:void 0,rotate:new Range(0,90)},super(t,i),this.build=function(){if(void 0===this.desiredCount){const t=isNaN(this.size)?this.size.min:this.size;this.desiredCount=Math.floor(this.width/t*this.height/t*10)}for(let t=0;t<this.desiredCount;t++){let t={size:Entanglement.getInt(this.size),fillColor:this.background};this.divisions&&(t.divisions=this.divisions),this.rotation&&(t.rotation=this.rotation),this.rotate&&(t.rotate=this.rotate),this.startCorner&&(t.startCorner=this.startCorner);new BoxSpiralElement(this.g,new Point(random(0,this.width),random(0,this.height)),t).draw()}},this.execute()}}class Ambler extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,void 0===i.gridShow&&(i.gridShow=!0),super(t,i),this.build=function(){const t=["nw","sw","se","ne"];let i=0,e=i+1;for(let s=0;s<this.gridPoints.length-1;s++){for(let e=0;e<this.gridPoints[s].length-1;e++){const n=this.gridPoints[s][e],h=this.gridPoints[s][e+1],o=this.gridPoints[s+1][e+1],r=this.gridPoints[s+1][e];BoxSpiralElement.newFromCoordinates(this.g,n,h,o,r,{startCorner:t[i%4],divisions:6,interior:!0}).draw(),i++}i=e++}},this.execute()}}class Emingle extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,void 0===i.gridShow&&(i.gridShow=!0),i.allowableOptions={startCorner:"nw"},super(t,i),this.build=function(){const t=["nw","sw","se","ne"];"random"===this.startCorner&&(this.startCorner=t[Math.floor(random(0,4))]);for(let t=0;t<this.gridPoints.length-1;t++)for(let i=0;i<this.gridPoints[t].length-1;i++){const e=this.gridPoints[t][i],s=this.gridPoints[t][i+1],n=this.gridPoints[t+1][i+1],h=this.gridPoints[t+1][i];BoxSpiralElement.newFromCoordinates(this.g,e,s,n,h,{startCorner:this.startCorner,divisions:6,interior:!0}).draw()}},this.execute()}}class Zentangle extends TangleBase{constructor(t,i,e){super(),void 0===e&&(e={}),e.allowableOptions={background:255,borderSize:30},this.loadOptions(e),this.width=t,this.height=t,this.shape=void 0===i?"square":i,"triangle"===this.shape&&(this.height*=.87),this.g=createGraphics(this.width,this.height);let s=new Point(this.width/2,this.height/2);switch(this.shape){case"circle":this.edgePoly=new Polygon;for(let t=0;t<360;t++)this.edgePoly.addVertex(new Polar(this.width/2-1,radians(t)).toPointCenter(s));this.borderPoly=new Polygon;for(let t=0;t<360;t++)this.borderPoly.addVertex(new Polar(this.width/2-this.borderSize,radians(t)).toPointCenter(s).vary(1));break;case"triangle":s=new Point(this.width/2,2*this.height/3),this.edgePoly=new Polygon([new Point(0,this.height),new Point(this.width/2,0),new Point(this.width,this.height)]);const t=2*this.height/3-2*this.borderSize;this.borderPoly=this._createBorderPolyFromLines([new Polar(t,radians(270)).toPointCenter(s),new Polar(t,radians(30)).toPointCenter(s),new Polar(t,radians(150)).toPointCenter(s)]);break;default:this.edgePoly=new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)]),this.borderPoly=this._createBorderPolyFromLines([new Point(this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.height-this.borderSize),new Point(this.borderSize,this.height-this.borderSize)])}this.areas=[],createCanvas(this.width,this.height),background(this.background)}getFullMask(){return new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)])}addTangle(t){this.areas.push(t),this.g.image(t.g,t.origin.x,t.origin.y)}draw(){let t,i=createGraphics(this.width,this.height);i.noStroke(),i.fill(255,255,255,0),i.beginShape();for(let t=0;t<this.edgePoly.vertices.length;t++)i.vertex(this.edgePoly.vertices[t].x,this.edgePoly.vertices[t].y);i.endShape(CLOSE),i.fill(255,255,255,255),i.beginShape();for(let t=0;t<this.borderPoly.vertices.length;t++)i.vertex(this.borderPoly.vertices[t].x,this.borderPoly.vertices[t].y);i.endShape(CLOSE),(t=this.g.get()).mask(i.get()),image(t,0,0),stroke(0),fill(255,255,255,0),beginShape();for(let t=0;t<this.borderPoly.vertices.length;t++)vertex(this.borderPoly.vertices[t].x,this.borderPoly.vertices[t].y);endShape(CLOSE),beginShape();for(let t=0;t<this.edgePoly.vertices.length;t++)vertex(this.edgePoly.vertices[t].x,this.edgePoly.vertices[t].y);endShape(CLOSE)}_createBorderPolyFromLines(t){let i=new Polygon;for(let e=0;e<t.length;e++){let s=e+1;s===t.length&&(s=0);const n=new Line(t[e],t[s]).handDrawn();for(let t=0;t<n.length;t++)i.addVertex(n[t])}return i}}
