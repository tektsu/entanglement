class Entanglement{static version="0.0.3";static getValue(i){let t=i;return isNaN(i)&&(t=i.rand()),t}static getInt(i){let t=i;return isNaN(i)&&(t=random(i.min,i.max+1)),Math.floor(t)}}class Point{constructor(i,t){this.x=i,this.y=t}add(i){this.x+=i.x,this.y+=i.y}rotate(i,t){const s=radians(i),e=this.x-t.x,n=this.y-t.y;this.x=e*cos(s)-n*sin(s)+t.x,this.y=e*sin(s)+n*cos(s)+t.y}}class Polar{constructor(i,t){this.r=i,this.a=t}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(i){let t=this.toPoint();return t.add(i),t}}class Line{constructor(i,t){this.begin=i,this.end=t}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(i){let t=[this.begin];const s=this.begin.x-this.end.x,e=this.begin.y-this.end.y;for(let n=1;n<=i;n++)t.push(new Point(this.begin.x-n*s/i,this.begin.y-n*e/i));return t}intersection(i){const t=(i.end.y-i.begin.y)*(this.end.x-this.begin.x)-(i.end.x-i.begin.x)*(this.end.y-this.begin.y);if(0==t)return;const s=this.begin.y-i.begin.y,e=this.begin.x-i.begin.x,n=((i.end.x-i.begin.x)*s-(i.end.y-i.begin.y)*e)/t,o=this.begin.x+n*(this.end.x-this.begin.x),h=this.begin.y+n*(this.end.y-this.begin.y);return new Point(o,h)}}class Box{constructor(i,t,s){this.position=i,this.width=void 0===t?100:t,this.height=void 0===s?100:s}static newFromXY(i,t,s,e){return void 0===i&&(i=0),void 0===t&&(t=0),new Box(new Point(i,t),s,e)}}class Range{constructor(i,t){i>t?(this.min=t,this.max=i):(this.min=i,this.max=t)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(i){void 0===i&&(i={}),"allowableOptions"in i||(i.allowableOptions={});for(const t in this.optionsAllowed)i.allowableOptions[t]=this.optionsAllowed[t];let t=i.allowableOptions;delete i.allowableOptions;for(const s in i)s in t?this[s]=i[s]:console.log("ERROR: Ignoring option: ",s);for(const i in t)void 0===this[i]&&void 0!==t[i]&&(this[i]=t[i])}}class TangleElement extends TangleBase{constructor(i,t,s){super(),this.g=i,this.center=null==t?Point(0,0):t,this.poly=[],this.optionsAllowed={debug:0,fillColor:0,strokeColor:0},this.loadOptions(s)}addVertex(i){this.poly.push(createVector(i.x,i.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(i,t,s){super(),this.width=i,this.height=t,this.g=createGraphics(i,t),this.gridPoints=[],this.optionsAllowed={debug:0,background:void 0,gridSpacing:void 0,gridXSpacing:40,gridYSpacing:40,gridVary:void 0,gridXVary:void 0,gridYVary:void 0,polys:[],avoidCollisions:!0},this.loadOptions(s),void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.02*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.02*this.gridYSpacing)}buildGridPoints(){for(let i=-this.gridYSpacing/2;i<this.height+this.gridYSpacing;i+=this.gridYSpacing){let t=[];for(let s=-this.gridXSpacing/2;s<this.width+this.gridXSpacing;s+=this.gridXSpacing)t.push(new Point(random(s-this.gridXVary,s+this.gridXVary),random(i-this.gridYVary,i+this.gridYVary)));this.gridPoints.push(t)}}grid(){0===this.gridPoints.length&&this.buildGridPoints();for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++){let s=this.gridPoints[i][t+1];void 0!==s&&this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y),void 0!==this.gridPoints[i+1]&&(s=this.gridPoints[i+1][t],this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y))}}collisionTest(i){if(!this.avoidCollisions)return!1;for(let t=0;t<this.polys.length;++t)if(collidePolyPoly(i,this.polys[t],!0))return!0;return!1}paste(i){image(this.g,i.x,i.y)}}class Dot extends TangleElement{constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={spacing:400,size:3},super(i,t,s),this.spacing=Math.max(100,this.spacing);let e=TWO_PI/8;for(let i=0;i<TWO_PI;i+=e)this.addVertex(new Polar(this.spacing/100*this.size,i).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(i,t,s){void 0===s&&(s={}),s.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:Aah.tipType.gap,size:100},super(i,t,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,n=this.rotate?random(0,e):0;for(let i=0;i<TWO_PI-e/2;i+=e){let t=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(i+n,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let o={start:new Polar(s,t.a).toPointCenter(this.center),stop:t.toPointCenter(this.center),tipCenter:new Polar(t.r*(this.tipDistancePercent/100),t.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(o);let h=Math.max(t.r,t.r*(this.tipDistancePercent/100))+o.tipDiameter/2;this.addVertex(new Polar(h+5*s,t.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*t.r,t.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(i=>{this.g.line(i.start.x,i.start.y,i.stop.x,i.stop.y),this.g.circle(i.tipCenter.x,i.tipCenter.y,i.tipDiameter)})}}class Aahs extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={plan:Aahs.plans.zentangle},s.plan=void 0===s.plan?Aahs.plans.zentangle:s.plan,super(i,t,s),void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let i=0,t=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const e=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;i<e;){let o=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),h={debug:this.debug,size:randomGaussian(s,n)};void 0!==this.plan.aah.armCount&&(h.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(h.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(h.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(h.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(h.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(h.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(h.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(h.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(h.strokeColor=this.plan.aah.strokeColor);const r=new Aah(this.g,o,h),a=r.getPoly();if(this.collisionTest(a)){if(++t,t>3*e)break}else this.polys.push(a),r.draw(),++i}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const i=void 0===this.plan.dot.size?3:this.plan.dot.size,t=!isNaN(i),s=2*(t?i:i.max),e=this.width/s*(this.height/s);for(let s=0;s<e;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let e={debug:this.debug,size:t?i:i.rand()};void 0!==this.plan.dot.spacing&&(e.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(e.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(e.strokeColor=this.plan.dot.strokeColor);const n=new Dot(this.g,s,e),o=n.getPoly();this.collisionTest(o)||(this.polys.push(o),n.draw())}}}}class BoxSpiralElement extends TangleElement{constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={divisions:4,nw:void 0,ne:void 0,se:void 0,sw:void 0,rotation:"ccw",size:50,startCorner:"nw",interior:!1,rotate:void 0},"fillColor"in s||(s.fillColor=color(0,0,0,0)),super(i,t,s),this.divisions=Entanglement.getInt(this.divisions),this.divisions=Math.max(this.interior?3:2,this.divisions),"random"===this.rotation&&(this.rotation=["cw","ccw"][Math.floor(random(0,2))]),"random"===this.startCorner&&(this.startCorner=["nw","ne","se","sw"][Math.floor(random(0,4))]),void 0===this.nw&&(this.nw=new Point(t.x-this.size/2,t.y-this.size/2)),void 0===this.ne&&(this.ne=new Point(t.x+this.size/2,t.y-this.size/2)),void 0===this.se&&(this.se=new Point(t.x+this.size/2,t.y+this.size/2)),void 0===this.sw&&(this.sw=new Point(t.x-this.size/2,t.y+this.size/2)),void 0!==this.rotate){const i=Entanglement.getValue(this.rotate);this.nw.rotate(i,this.center),this.ne.rotate(i,this.center),this.se.rotate(i,this.center),this.sw.rotate(i,this.center)}this.addVertex(this.nw),this.addVertex(this.ne),this.addVertex(this.se),this.addVertex(this.sw),this.pointPool=this._pointPool()}static newFromCoordinates(i,t,s,e,n,o){return void 0===o&&(o={}),o.nw=t,o.ne=s,o.se=e,o.sw=n,new BoxSpiralElement(i,new Point((t.x+s.x+e.x+n.x)/4,(t.y+s.y+e.y+n.y)/4),o)}draw(){this.g.noStroke(),this.g.fill(this.fillColor),this.g.beginShape(),this.g.vertex(this.nw.x,this.nw.y),this.g.vertex(this.ne.x,this.ne.y),this.g.vertex(this.se.x,this.se.y),this.g.vertex(this.sw.x,this.sw.y),this.g.endShape(CLOSE),this.g.stroke(this.strokeColor),this.current=this._firstPoint();let i=0;for(;;){const t=this._nextPoint();if(void 0===t)break;if(this.g.line(this.pointPool[this.current].x,this.pointPool[this.current].y,this.pointPool[t].x,this.pointPool[t].y),this.current=t,++i>5*this.divisions){console.log("BoxSpiralElement - runaway spiral?");break}}}_pointPool(){const i=new Line(this.nw,this.sw).divide(this.divisions),t=new Line(this.ne,this.se).divide(this.divisions),s=new Line(this.nw,this.ne).divide(this.divisions),e=new Line(this.sw,this.se).divide(this.divisions);let n=[],o=[];for(let h=0;h<=this.divisions;h++)n.push(new Line(s[h],e[h])),o.push(new Line(i[h],t[h]));let h=[];for(let i=0;i<=this.divisions;i++)for(let t=0;t<=this.divisions;t++)h.push(o[i].intersection(n[t]));return h}_nextDirection(){this.direction=this.direction+("ccw"===this.rotation?1:-1)%4}_firstPoint(){switch(this.direction=4*this.divisions,"cw"===this.rotation&&this.direction++,this.current=this.interior?this.divisions+2:0,this.step=this.interior?2:0,this.levelCount=3,this.startCorner){case"ne":this.current=this.interior?2*this.divisions:this.divisions,this.direction+=3;break;case"se":this.current=this.interior?Math.pow(this.divisions,2)+this.divisions-2:Math.pow(this.divisions+1,2)-1,this.direction+=2;break;case"sw":this.current=this.interior?Math.pow(this.divisions,2):this.divisions*(this.divisions+1),this.direction+=1}return this.current}_nextPoint(){let i;const t=this.divisions-this.step;if(0===t)return i;switch(this.direction%4){case 0:i=this.current+t*(this.divisions+1);break;case 1:i=this.current+t;break;case 2:i=this.current-t*(this.divisions+1);break;case 3:i=this.current-t}return 0==--this.levelCount&&(++this.step,this.levelCount=2),this._nextDirection(),i}}class BoxSpiral extends Tangle{constructor(i,t,s){if(void 0===s&&(s={}),s.allowableOptions={size:50,desiredCount:void 0,divisions:void 0,rotation:void 0,startCorner:void 0,rotate:new Range(0,90)},super(i,t,s),void 0===this.desiredCount){const i=isNaN(this.size)?this.size.min:this.size;this.desiredCount=this.width/i*this.height/i*10}for(let i=0;i<this.desiredCount;i++){let i={size:Entanglement.getInt(this.size),fillColor:this.background};this.divisions&&(i.divisions=this.divisions),this.rotation&&(i.rotation=this.rotation),this.rotate&&(i.rotate=this.rotate),this.startCorner&&(i.startCorner=this.startCorner);new BoxSpiralElement(this.g,new Point(random(0,this.width),random(0,this.height)),i).draw()}}}class Ambler extends Tangle{constructor(i,t,s){void 0===s&&(s={}),super(i,t,s),this.buildGridPoints();const e=["nw","sw","se","ne"];let n=0,o=n+1;for(let i=0;i<this.gridPoints.length-1;i++){for(let t=0;t<this.gridPoints[i].length-1;t++){const s=this.gridPoints[i][t],o=this.gridPoints[i][t+1],h=this.gridPoints[i+1][t+1],r=this.gridPoints[i+1][t];BoxSpiralElement.newFromCoordinates(this.g,s,o,h,r,{startCorner:e[n%4],divisions:6,interior:!0}).draw(),n++}n=o++}this.grid()}}
