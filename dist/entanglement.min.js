class Point{constructor(i,t){this.x=i,this.y=t}add(i){this.x+=i.x,this.y+=i.y}}class Polar{constructor(i,t){this.r=i,this.a=t}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(i){let t=this.toPoint();return t.add(i),t}}class Line{constructor(i,t){this.begin=i,this.end=t}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(i){let t=[this.begin];const s=this.begin.x-this.end.x,e=this.begin.y-this.end.y;for(let n=1;n<=i;n++)t.push(new Point(this.begin.x-n*s/i,this.begin.y-n*e/i));return t}intersection(i){const t=(i.end.y-i.begin.y)*(this.end.x-this.begin.x)-(i.end.x-i.begin.x)*(this.end.y-this.begin.y);if(0==t)return;const s=this.begin.y-i.begin.y,e=this.begin.x-i.begin.x,n=((i.end.x-i.begin.x)*s-(i.end.y-i.begin.y)*e)/t,a=this.begin.x+n*(this.end.x-this.begin.x),o=this.begin.y+n*(this.end.y-this.begin.y);return new Point(a,o)}}class Box{constructor(i,t,s){this.position=i,this.width=void 0===t?100:t,this.height=void 0===s?100:s}static newFromXY(i,t,s,e){return void 0===i&&(i=0),void 0===t&&(t=0),new Box(new Point(i,t),s,e)}}class Range{constructor(i,t){i>t?(this.min=t,this.max=i):(this.min=i,this.max=t)}rand(){return random(this.min,this.max)}}class TangleElement{constructor(i,t,s){this.g=i,this.center=null==t?Point(0,0):t,this.poly=[],this.debug=!1,this.fillColor=0,this.strokeColor=0;let e=["g","center","poly"].reduce((function(i,t){return i[t]=void 0,i}),{});void 0===typeof s&&(s={}),"allowableOptions"in s||(s.allowableOptions=[]),s.allowableOptions=s.allowableOptions.concat(["debug","fillColor","strokeColor"]);let n=s.allowableOptions.reduce((function(i,t){return t in e||(i[t]=void 0),i}),{});delete s.allowableOptions;for(const i in s)i in n?this[i]=s[i]:console.log("ERROR: Ignoring option: ",i)}addVertex(i){this.poly.push(createVector(i.x,i.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle{constructor(i,t,s){this.width=i,this.height=t,this.g=createGraphics(i,t),this.background=void 0,this.gridXSpacing=20,this.gridYSpacing=20,this.debug=!1,this.gridPoints=[],this.polys=[],this.avoidCollisions=!0;let e=["g","width","height","gridPoints"].reduce((function(i,t){return i[t]=void 0,i}),{});void 0===typeof s&&(s={}),"allowableOptions"in s||(s.allowableOptions=[]),s.allowableOptions=s.allowableOptions.concat(["background","gridSpacing","gridXSpacing","gridYSpacing","gridVary","gridXVary","gridYVary","poly","avoidCollisions","debug"]);let n=s.allowableOptions.reduce((function(i,t){return t in e||(i[t]=void 0),i}),{});delete s.allowableOptions;for(const i in s)i in n?this[i]=s[i]:console.log("ERROR: Ignoring option: ",i);void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.05*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.05*this.gridYSpacing)}buildGridPoints(){for(let i=-this.gridYSpacing/2;i<this.height+this.gridYSpacing;i+=this.gridYSpacing){let t=[];for(let s=-this.gridXSpacing/2;s<this.width+this.gridXSpacing;s+=this.gridXSpacing)t.push(new Point(random(s-this.gridXVary,s+this.gridXVary),random(i-this.gridYVary,i+this.gridYVary)));this.gridPoints.push(t)}}grid(){0===this.gridPoints.length&&this.buildGridPoints();for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++){let s=this.gridPoints[i][t+1];void 0!==s&&this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y),void 0!==this.gridPoints[i+1]&&(s=this.gridPoints[i+1][t],this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y))}}collisionTest(i){if(!this.avoidCollisions)return!1;for(let t=0;t<this.polys.length;++t)if(collidePolyPoly(i,this.polys[t],!0))return!0;return!1}paste(i){image(this.g,i.x,i.y)}}class Dot extends TangleElement{constructor(i,t,s){null==typeof s&&(s={}),s.allowableOptions=["spacing","size"],s.spacing=void 0===s.spacing?400:s.spacing,s.size=void 0===s.size?3:s.size,super(i,t,s),this.spacing=Math.max(100,this.spacing);let e=TWO_PI/8;for(let i=0;i<TWO_PI;i+=e)this.addVertex(new Polar(this.spacing/100*this.size,i).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(i,t,s){null==typeof s&&(s={}),s.allowableOptions=["armCount","thetaSD","lengthSDP","gapSDP","rotate","tipDistancePercent","tipDiameter","size"],s.armCount=void 0===s.armCount?8:s.armCount,s.thetaSD=void 0===s.thetaSD?5:s.thetaSD,s.lengthSDP=void 0===s.lengthSDP?15:s.lengthSDP,s.gapSDP=void 0===s.gapSDP?10:s.gapSDP,s.rotate=void 0===s.rotate||s.rotate,s.tipDistancePercent=void 0===s.tipDistancePercent?100:s.tipDistancePercent,s.tipDiameter=void 0===s.tipDiameter?Aah.tipType.gap:s.tipDiameter,s.size=void 0===s.size?100:s.size,super(i,t,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,n=this.rotate?random(0,e):0;for(let i=0;i<TWO_PI-e/2;i+=e){let t=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(i+n,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let a={start:new Polar(s,t.a).toPointCenter(this.center),stop:t.toPointCenter(this.center),tipCenter:new Polar(t.r*(this.tipDistancePercent/100),t.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(a);let o=Math.max(t.r,t.r*(this.tipDistancePercent/100))+a.tipDiameter/2;this.addVertex(new Polar(o+5*s,t.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*t.r,t.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(i=>{this.g.line(i.start.x,i.start.y,i.stop.x,i.stop.y),this.g.circle(i.tipCenter.x,i.tipCenter.y,i.tipDiameter)})}}class Aahs extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(i,t,s){if(null==typeof s&&(s={plan:Aahs.plans.zentangle}),s.allowableOptions=["plan"],s.plan=void 0===s.plan?Aahs.plans.zentangle:s.plan,super(i,t,s),void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let i=0,t=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const e=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;i<e;){let a=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),o={debug:this.debug,size:randomGaussian(s,n)};void 0!==this.plan.aah.armCount&&(o.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(o.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(o.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(o.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(o.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(o.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(o.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(o.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(o.strokeColor=this.plan.aah.strokeColor);const h=new Aah(this.g,a,o),r=h.getPoly();if(this.collisionTest(r)){if(++t,t>3*e)break}else this.polys.push(r),h.draw(),++i}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const i=void 0===this.plan.dot.size?3:this.plan.dot.size,t=!isNaN(i),s=2*(t?i:i.max),e=this.width/s*(this.height/s);for(let s=0;s<e;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let e={debug:this.debug,size:t?i:i.rand()};void 0!==this.plan.dot.spacing&&(e.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(e.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(e.strokeColor=this.plan.dot.strokeColor);const n=new Dot(this.g,s,e),a=n.getPoly();this.collisionTest(a)||(this.polys.push(a),n.draw())}}}}class Ambler extends Tangle{constructor(i,t,s){null==typeof s&&(s={}),super(i,t,s),this.grid();let e=0,n=e+1;for(let i=0;i<this.gridPoints.length-1;i++){for(let t=0;t<this.gridPoints[i].length-1;t++){const s=this._pointPool(this.gridPoints[i][t],this.gridPoints[i][t+1],this.gridPoints[i+1][t+1],this.gridPoints[i+1][t]);let n=[];switch(e%4){case 0:n=[s[0],s[14],s[16],s[2],s[1],s[11],s[13],s[5],s[4],s[8]];break;case 1:n=[s[14],s[16],s[2],s[0],s[10],s[13],s[5],s[3],s[7],s[8]];break;case 2:n=[s[16],s[2],s[0],s[14],s[15],s[5],s[3],s[11],s[12],s[8]];break;case 3:n=[s[2],s[0],s[14],s[16],s[6],s[3],s[11],s[13],s[9],s[8]]}for(let i=1;i<n.length;i++)this.g.line(n[i-1].x,n[i-1].y,n[i].x,n[i].y);e++}e=n++}}_pointPool(i,t,s,e){const n=new Line(i,e).divide(6),a=new Line(t,s).divide(6),o=new Line(i,t).divide(6),h=new Line(e,s).divide(6);let r=[],l=[];for(let i=1;i<6;i++)r.push(new Line(o[i],h[i])),l.push(new Line(n[i],a[i]));return[l[0].intersection(r[0]),l[0].intersection(r[1]),l[0].intersection(r[4]),l[1].intersection(r[1]),l[1].intersection(r[2]),l[1].intersection(r[3]),l[1].intersection(r[4]),l[2].intersection(r[1]),l[2].intersection(r[2]),l[2].intersection(r[3]),l[3].intersection(r[0]),l[3].intersection(r[1]),l[3].intersection(r[2]),l[3].intersection(r[3]),l[4].intersection(r[0]),l[4].intersection(r[3]),l[4].intersection(r[4])]}}
