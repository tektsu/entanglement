class Point{constructor(i,t){this.x=i,this.y=t}add(i){this.x+=i.x,this.y+=i.y}}class Polar{constructor(i,t){this.r=i,this.a=t}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(i){let t=this.toPoint();return t.add(i),t}}class Line{constructor(i,t){this.begin=i,this.end=t}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(i){let t=[this.begin];const s=this.begin.x-this.end.x,n=this.begin.y-this.end.y;for(let e=1;e<=i;e++)t.push(new Point(this.begin.x-e*s/i,this.begin.y-e*n/i));return t}intersection(i){const t=(i.end.y-i.begin.y)*(this.end.x-this.begin.x)-(i.end.x-i.begin.x)*(this.end.y-this.begin.y);if(0==t)return;const s=this.begin.y-i.begin.y,n=this.begin.x-i.begin.x,e=((i.end.x-i.begin.x)*s-(i.end.y-i.begin.y)*n)/t,o=this.begin.x+e*(this.end.x-this.begin.x),a=this.begin.y+e*(this.end.y-this.begin.y);return new Point(o,a)}}class Box{constructor(i,t,s){this.position=i,this.width=void 0===t?100:t,this.height=void 0===s?100:s}static newFromXY(i,t,s,n){return void 0===i&&(i=0),void 0===t&&(t=0),new Box(new Point(i,t),s,n)}}class Range{constructor(i,t){i>t?(this.min=t,this.max=i):(this.min=i,this.max=t)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(i){void 0===i&&(i={}),"allowableOptions"in i||(i.allowableOptions={});for(const t in this.optionsAllowed)i.allowableOptions[t]=this.optionsAllowed[t];let t=i.allowableOptions;delete i.allowableOptions;for(const s in i)s in t?this[s]=i[s]:console.log("ERROR: Ignoring option: ",s);for(const i in t)void 0===this[i]&&void 0!==t[i]&&(this[i]=t[i])}}class TangleElement extends TangleBase{constructor(i,t,s){super(),this.g=i,this.center=null==t?Point(0,0):t,this.poly=[],this.debug=!1,this.fillColor=0,this.strokeColor=0,this.optionsAllowed={debug:!1,fillColor:0,strokeColor:0},this.loadOptions(s)}addVertex(i){this.poly.push(createVector(i.x,i.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(i,t,s){super(),this.width=i,this.height=t,this.g=createGraphics(i,t),this.background=void 0,this.gridXSpacing=20,this.gridYSpacing=20,this.debug=!1,this.gridPoints=[],this.polys=[],this.avoidCollisions=!0,this.optionsAllowed={background:void 0,gridSpacing:void 0,gridXSpacing:20,gridYSpacing:20,gridVary:void 0,gridXVary:void 0,gridYVary:void 0,poly:[],avoidCollisions:!0,debug:!1},this.loadOptions(s),void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.05*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.05*this.gridYSpacing)}buildGridPoints(){for(let i=-this.gridYSpacing/2;i<this.height+this.gridYSpacing;i+=this.gridYSpacing){let t=[];for(let s=-this.gridXSpacing/2;s<this.width+this.gridXSpacing;s+=this.gridXSpacing)t.push(new Point(random(s-this.gridXVary,s+this.gridXVary),random(i-this.gridYVary,i+this.gridYVary)));this.gridPoints.push(t)}}grid(){0===this.gridPoints.length&&this.buildGridPoints();for(let i=0;i<this.gridPoints.length;i++)for(let t=0;t<this.gridPoints[i].length;t++){let s=this.gridPoints[i][t+1];void 0!==s&&this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y),void 0!==this.gridPoints[i+1]&&(s=this.gridPoints[i+1][t],this.g.line(this.gridPoints[i][t].x,this.gridPoints[i][t].y,s.x,s.y))}}collisionTest(i){if(!this.avoidCollisions)return!1;for(let t=0;t<this.polys.length;++t)if(collidePolyPoly(i,this.polys[t],!0))return!0;return!1}paste(i){image(this.g,i.x,i.y)}}class Dot extends TangleElement{constructor(i,t,s){null==typeof s&&(s={}),s.allowableOptions={spacing:400,size:3},super(i,t,s),this.spacing=Math.max(100,this.spacing);let n=TWO_PI/8;for(let i=0;i<TWO_PI;i+=n)this.addVertex(new Polar(this.spacing/100*this.size,i).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(i,t,s){void 0===typeof s&&(s={}),s.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:Aah.tipType.gap,size:100},super(i,t,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const n=TWO_PI/this.armCount,e=this.rotate?random(0,n):0;for(let i=0;i<TWO_PI-n/2;i+=n){let t=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(i+e,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let o={start:new Polar(s,t.a).toPointCenter(this.center),stop:t.toPointCenter(this.center),tipCenter:new Polar(t.r*(this.tipDistancePercent/100),t.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(o);let a=Math.max(t.r,t.r*(this.tipDistancePercent/100))+o.tipDiameter/2;this.addVertex(new Polar(a+5*s,t.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*t.r,t.a+n/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(i=>{this.g.line(i.start.x,i.start.y,i.stop.x,i.stop.y),this.g.circle(i.tipCenter.x,i.tipCenter.y,i.tipDiameter)})}}class Aahs extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(i,t,s){if(null==typeof s&&(s={}),s.allowableOptions={plan:Aahs.plans.zentangle},s.plan=void 0===s.plan?Aahs.plans.zentangle:s.plan,super(i,t,s),void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let i=0,t=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const n=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,e=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;i<n;){let o=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),a={debug:this.debug,size:randomGaussian(s,e)};void 0!==this.plan.aah.armCount&&(a.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(a.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(a.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(a.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(a.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(a.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(a.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(a.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(a.strokeColor=this.plan.aah.strokeColor);const h=new Aah(this.g,o,a),r=h.getPoly();if(this.collisionTest(r)){if(++t,t>3*n)break}else this.polys.push(r),h.draw(),++i}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const i=void 0===this.plan.dot.size?3:this.plan.dot.size,t=!isNaN(i),s=2*(t?i:i.max),n=this.width/s*(this.height/s);for(let s=0;s<n;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let n={debug:this.debug,size:t?i:i.rand()};void 0!==this.plan.dot.spacing&&(n.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(n.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(n.strokeColor=this.plan.dot.strokeColor);const e=new Dot(this.g,s,n),o=e.getPoly();this.collisionTest(o)||(this.polys.push(o),e.draw())}}}}class Ambler extends Tangle{constructor(i,t,s){null==typeof s&&(s={}),super(i,t,s),this.grid();let n=0,e=n+1;for(let i=0;i<this.gridPoints.length-1;i++){for(let t=0;t<this.gridPoints[i].length-1;t++){const s=this._pointPool(this.gridPoints[i][t],this.gridPoints[i][t+1],this.gridPoints[i+1][t+1],this.gridPoints[i+1][t]);let e=[];switch(n%4){case 0:e=[s[0],s[14],s[16],s[2],s[1],s[11],s[13],s[5],s[4],s[8]];break;case 1:e=[s[14],s[16],s[2],s[0],s[10],s[13],s[5],s[3],s[7],s[8]];break;case 2:e=[s[16],s[2],s[0],s[14],s[15],s[5],s[3],s[11],s[12],s[8]];break;case 3:e=[s[2],s[0],s[14],s[16],s[6],s[3],s[11],s[13],s[9],s[8]]}for(let i=1;i<e.length;i++)this.g.line(e[i-1].x,e[i-1].y,e[i].x,e[i].y);n++}n=e++}}_pointPool(i,t,s,n){const e=new Line(i,n).divide(6),o=new Line(t,s).divide(6),a=new Line(i,t).divide(6),h=new Line(n,s).divide(6);let r=[],l=[];for(let i=1;i<6;i++)r.push(new Line(a[i],h[i])),l.push(new Line(e[i],o[i]));return[l[0].intersection(r[0]),l[0].intersection(r[1]),l[0].intersection(r[4]),l[1].intersection(r[1]),l[1].intersection(r[2]),l[1].intersection(r[3]),l[1].intersection(r[4]),l[2].intersection(r[1]),l[2].intersection(r[2]),l[2].intersection(r[3]),l[3].intersection(r[0]),l[3].intersection(r[1]),l[3].intersection(r[2]),l[3].intersection(r[3]),l[4].intersection(r[0]),l[4].intersection(r[3]),l[4].intersection(r[4])]}}
