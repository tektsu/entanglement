class Entanglement{static version="0.0.6";static getValue(t){let i=t;return isNaN(t)&&(i=t.rand()),i}static getInt(t){let i=t;return isNaN(t)&&(i=random(t.min,t.max+1)),Math.floor(i)}}class Point{constructor(t,i){this.x=t,this.y=i}add(t){this.x+=t.x,this.y+=t.y}rotate(t,i){const s=radians(t),e=this.x-i.x,n=this.y-i.y;this.x=e*cos(s)-n*sin(s)+i.x,this.y=e*sin(s)+n*cos(s)+i.y}vary(t){return this.x+=random(-t,t),this.y+=random(-t,t),this}}class Polar{constructor(t,i){this.r=t,this.a=i}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(t){let i=this.toPoint();return i.add(t),i}}class Line{constructor(t,i){this.begin=t,this.end=i}length(){return Math.sqrt(Math.pow(this.begin.x-this.end.x,2)+Math.pow(this.begin.y-this.end.y,2))}divide(t){let i=[this.begin];const s=this.begin.x-this.end.x,e=this.begin.y-this.end.y;for(let n=1;n<=t;n++)i.push(new Point(this.begin.x-n*s/t,this.begin.y-n*e/t));return i}handDrawn(t,i){if(void 0===t&&(t=Math.floor(this.length()/6)),0===t)return[this.begin,this.end];void 0===i&&(i=1);let s=[];const e=this.divide(t);for(let t=0;t<e.length;t++)0===t||t===e.length-1?s.push(e[t]):s.push(e[t].vary(i));return s}intersection(t){const i=(t.end.y-t.begin.y)*(this.end.x-this.begin.x)-(t.end.x-t.begin.x)*(this.end.y-this.begin.y);if(0==i)return;const s=this.begin.y-t.begin.y,e=this.begin.x-t.begin.x,n=((t.end.x-t.begin.x)*s-(t.end.y-t.begin.y)*e)/i,h=this.begin.x+n*(this.end.x-this.begin.x),o=this.begin.y+n*(this.end.y-this.begin.y);return new Point(h,o)}}class Polygon{constructor(t){this.boundingRectangle=void 0,this.vertices=[],void 0!==t&&(this.vertices=t)}addVertex(t){this.vertices.push(t),this.boundingRectangle=void 0}getBoundingRectangle(){if(void 0===this.boundingRectangle){let t=this.vertices[0].x,i=this.vertices[0].y,s=t,e=i;for(let n=1;n<this.vertices.length;n++)this.vertices[n].x<t&&(t=this.vertices[n].x),this.vertices[n].y<i&&(i=this.vertices[n].y),this.vertices[n].x>s&&(s=this.vertices[n].x),this.vertices[n].y>e&&(e=this.vertices[n].y);this.boundingRectangle=new Polygon([new Point(t,i),new Point(s,i),new Point(s,e),new Point(t,e)])}return this.boundingRectangle}getCenter(){return this.getBoundingRectangle(),new Point((this.boundingRectangle.vertices[0].x+this.boundingRectangle.vertices[1].x)/2,(this.boundingRectangle.vertices[0].y+this.boundingRectangle.vertices[3].y)/2)}getOrigin(){return this.getBoundingRectangle(),this.boundingRectangle.vertices[0]}getWidth(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].x-this.boundingRectangle.vertices[0].x)}getHeight(){return this.getBoundingRectangle(),Math.ceil(this.boundingRectangle.vertices[2].y-this.boundingRectangle.vertices[0].y)}rotate(t,i){void 0===i&&(i=this.getCenter());for(let s=0;s<this.vertices.length;s++)this.vertices[s].rotate(t,i);this.boundingRectangle=void 0}copy(){const t=new Polygon;for(let i=0;i<this.vertices.length;i++)t.addVertex(new Point(this.vertices[i].x,this.vertices[i].y));return t}}class Range{constructor(t,i){t>i?(this.min=i,this.max=t):(this.min=t,this.max=i)}rand(){return random(this.min,this.max)}}class TangleBase{constructor(){}loadOptions(t){void 0===t&&(t={}),"allowableOptions"in t||(t.allowableOptions={});for(const i in this.optionsAllowed)t.allowableOptions[i]=this.optionsAllowed[i];let i=t.allowableOptions;delete t.allowableOptions;for(const s in t)s in i?this[s]=t[s]:console.log("ERROR: Ignoring option: ",s);for(const t in i)void 0===this[t]&&void 0!==i[t]&&(this[t]=i[t])}}class TangleElement extends TangleBase{constructor(t,i,s){super(),this.g=t,this.center=null==i?Point(0,0):i,this.poly=[],this.optionsAllowed={debug:0,fillColor:0,strokeColor:0},this.loadOptions(s)}addVertex(t){this.poly.push(createVector(t.x,t.y))}getPoly(){return this.poly}draw(){this.g.fill(this.fillColor),this.g.stroke(this.strokeColor)}}class Tangle extends TangleBase{constructor(t,i){super(),this.maskPoly=t,Array.isArray(t)&&(this.maskPoly=new Polygon(t)),this.gridPoints=[],this.build=function(){},this.optionsAllowed={debug:0,background:void 0,grid:!1,gridShow:!1,gridSpacing:void 0,gridXSpacing:40,gridYSpacing:40,gridVary:void 0,gridXVary:void 0,gridYVary:void 0,polys:[],avoidCollisions:!0,addStrings:!0,ignoreMask:!1,tangleRotate:0},this.loadOptions(i);const s=this.maskPoly.getBoundingRectangle().copy();if(this.origin=s.getOrigin(),this.width=s.getWidth(),this.height=s.getHeight(),this.tangleRotate){let t=this.origin.x,i=this.origin.y,e=t+this.width,n=i+this.height;s.rotate(this.tangleRotate);const h=s.getOrigin(),o=s.getWidth(),r=s.getHeight();t=Math.floor(Math.min(t,h.x)),i=Math.floor(Math.min(i,h.y)),e=Math.ceil(Math.max(e,h.x+o)),n=Math.ceil(Math.max(n,h.y+r)),this.origin=new Point(t,i),this.width=e-t,this.height=n-i}if(this.g=createGraphics(this.width,this.height),this.tangleRotate){const t=radians(this.tangleRotate),i=this.width/2,s=this.height/2,e=Math.floor(i-(i*cos(t)-s*sin(t))),n=Math.floor(s-(i*sin(t)+s*cos(t)));this.g.translate(e,n),this.g.rotate(t)}void 0!==this.background&&this.g.background(this.background),void 0!==this.gridSpacing&&(this.gridXSpacing=this.gridYSpacing=this.gridSpacing),void 0!==this.gridVary&&(this.gridXVary=this.gridYVary=this.gridVary),void 0===this.gridXVary&&(this.gridXVary=.02*this.gridXSpacing),void 0===this.gridYVary&&(this.gridYVary=.02*this.gridYSpacing)}buildGridPoints(){for(let t=-this.gridYSpacing/2;t<this.height+this.gridYSpacing;t+=this.gridYSpacing){let i=[];for(let s=-this.gridXSpacing/2;s<this.width+this.gridXSpacing;s+=this.gridXSpacing)i.push(new Point(random(s-this.gridXVary,s+this.gridXVary),random(t-this.gridYVary,t+this.gridYVary)));this.gridPoints.push(i)}}showGrid(){0===this.gridPoints.length&&this.buildGridPoints();for(let t=0;t<this.gridPoints.length;t++)for(let i=0;i<this.gridPoints[t].length;i++){let s=this.gridPoints[t][i+1];void 0!==s&&this.g.line(this.gridPoints[t][i].x,this.gridPoints[t][i].y,s.x,s.y),void 0!==this.gridPoints[t+1]&&(s=this.gridPoints[t+1][i],this.g.line(this.gridPoints[t][i].x,this.gridPoints[t][i].y,s.x,s.y))}}collisionTest(t){if(!this.avoidCollisions)return!1;for(let i=0;i<this.polys.length;++i)if(collidePolyPoly(t,this.polys[i],!0))return!0;return!1}paste(t){image(this.g,t.x,t.y)}applyMask(){if(this.ignoreMask)return;let t,i=createGraphics(this.width,this.height);i.noStroke(),i.fill(255,255,255,255),i.beginShape();for(let t=0;t<this.maskPoly.vertices.length;t++)i.vertex(this.maskPoly.vertices[t].x-this.origin.x,this.maskPoly.vertices[t].y-this.origin.y);if(i.endShape(CLOSE),(t=this.g.get()).mask(i.get()),this.g=createGraphics(this.width,this.height),this.g.image(t,0,0),this.addStrings){this.g.stroke(0),this.g.fill(0,0,0,0),this.g.beginShape();for(let t=0;t<this.maskPoly.vertices.length;t++)this.g.vertex(this.maskPoly.vertices[t].x-this.origin.x,this.maskPoly.vertices[t].y-this.origin.y);this.g.endShape(CLOSE)}}execute(){this.grid&&this.buildGridPoints(),this.build(),this.grid&&this.gridShow&&this.showGrid(),this.ignoreMask||this.applyMask()}}class DotElement extends TangleElement{constructor(t,i,s){void 0===s&&(s={}),s.allowableOptions={spacing:400,size:3},super(t,i,s),this.spacing=Math.max(100,this.spacing);let e=TWO_PI/8;for(let t=0;t<TWO_PI;t+=e)this.addVertex(new Polar(this.spacing/100*this.size,t).toPointCenter(this.center))}draw(){super.draw(),this.g.circle(this.center.x,this.center.y,this.size)}}class AahElement extends TangleElement{static tipType={gap:"gap"};constructor(t,i,s){void 0===s&&(s={}),s.allowableOptions={armCount:8,thetaSD:5,lengthSDP:15,gapSDP:10,rotate:!0,tipDistancePercent:100,tipDiameter:AahElement.tipType.gap,size:100},super(t,i,s),this.length=this.size/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,n=this.rotate?random(0,e):0;for(let t=0;t<TWO_PI-e/2;t+=e){let i=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(t+n,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(s,i.a).toPointCenter(this.center),stop:i.toPointCenter(this.center),tipCenter:new Polar(i.r*(this.tipDistancePercent/100),i.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===AahElement.tipType.gap?s:10:this.tipDiameter};this.arms.push(h);let o=Math.max(i.r,i.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(o+5*s,i.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*i.r,i.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(t=>{this.g.line(t.start.x,t.start.y,t.stop.x,t.stop.y),this.g.circle(t.tipCenter.x,t.tipCenter.y,t.tipDiameter)})}}class Aah extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(t,i){void 0===i&&(i={}),i.allowableOptions={plan:Aah.plans.zentangle},i.plan=void 0===i.plan?Aah.plans.zentangle:i.plan,super(t,i),this.build=function(){if(void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={}),void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let t=0,i=0;const s=void 0===this.plan.aah.size?Math.min(this.width,this.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const e=void 0===this.plan.aah.desiredCount?this.width/s*(this.height/s)*10:this.plan.aah.desiredCount,n=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;t<e;){let h=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin)),o={debug:this.debug,size:randomGaussian(s,n)};void 0!==this.plan.aah.armCount&&(o.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(o.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(o.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(o.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(o.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(o.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(o.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(o.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(o.strokeColor=this.plan.aah.strokeColor);const r=new AahElement(this.g,h,o),a=r.getPoly();if(this.collisionTest(a)){if(++i,i>3*e)break}else this.polys.push(a),r.draw(),++t}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const t=void 0===this.plan.dot.size?3:this.plan.dot.size,i=!isNaN(t),s=2*(i?t:t.max),e=this.width/s*(this.height/s);for(let s=0;s<e;++s){const s=new Point(random(this.margin,this.width-this.margin),random(this.margin,this.height-this.margin));let e={debug:this.debug,size:i?t:t.rand()};void 0!==this.plan.dot.spacing&&(e.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(e.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(e.strokeColor=this.plan.dot.strokeColor);const n=new DotElement(this.g,s,e),h=n.getPoly();this.collisionTest(h)||(this.polys.push(h),n.draw())}}},this.execute()}}class BoxSpiralElement extends TangleElement{constructor(t,i,s){if(void 0===s&&(s={}),s.allowableOptions={divisions:4,nw:void 0,ne:void 0,se:void 0,sw:void 0,rotation:"ccw",size:50,startCorner:"nw",interior:!1,rotate:void 0},"fillColor"in s||(s.fillColor=color(0,0,0,0)),super(t,i,s),this.divisions=Entanglement.getInt(this.divisions),this.divisions=Math.max(this.interior?3:2,this.divisions),"random"===this.rotation&&(this.rotation=["cw","ccw"][Math.floor(random(0,2))]),"random"===this.startCorner&&(this.startCorner=["nw","ne","se","sw"][Math.floor(random(0,4))]),void 0===this.nw&&(this.nw=new Point(i.x-this.size/2,i.y-this.size/2)),void 0===this.ne&&(this.ne=new Point(i.x+this.size/2,i.y-this.size/2)),void 0===this.se&&(this.se=new Point(i.x+this.size/2,i.y+this.size/2)),void 0===this.sw&&(this.sw=new Point(i.x-this.size/2,i.y+this.size/2)),void 0!==this.rotate){const t=Entanglement.getValue(this.rotate);this.nw.rotate(t,this.center),this.ne.rotate(t,this.center),this.se.rotate(t,this.center),this.sw.rotate(t,this.center)}this.addVertex(this.nw),this.addVertex(this.ne),this.addVertex(this.se),this.addVertex(this.sw),this.pointPool=this._pointPool()}static newFromCoordinates(t,i,s,e,n,h){return void 0===h&&(h={}),h.nw=i,h.ne=s,h.se=e,h.sw=n,new BoxSpiralElement(t,new Point((i.x+s.x+e.x+n.x)/4,(i.y+s.y+e.y+n.y)/4),h)}draw(){this.g.noStroke(),this.g.fill(this.fillColor),this.g.beginShape(),this.g.vertex(this.nw.x,this.nw.y),this.g.vertex(this.ne.x,this.ne.y),this.g.vertex(this.se.x,this.se.y),this.g.vertex(this.sw.x,this.sw.y),this.g.endShape(CLOSE),this.g.stroke(this.strokeColor),this.current=this._firstPoint();let t=0;for(;;){const i=this._nextPoint();if(void 0===i)break;if(this.g.line(this.pointPool[this.current].x,this.pointPool[this.current].y,this.pointPool[i].x,this.pointPool[i].y),this.current=i,++t>5*this.divisions){console.log("BoxSpiralElement - runaway spiral?");break}}}_pointPool(){const t=new Line(this.nw,this.sw).divide(this.divisions),i=new Line(this.ne,this.se).divide(this.divisions),s=new Line(this.nw,this.ne).divide(this.divisions),e=new Line(this.sw,this.se).divide(this.divisions);let n=[],h=[];for(let o=0;o<=this.divisions;o++)n.push(new Line(s[o],e[o])),h.push(new Line(t[o],i[o]));let o=[];for(let t=0;t<=this.divisions;t++)for(let i=0;i<=this.divisions;i++)o.push(h[t].intersection(n[i]));return o}_nextDirection(){this.direction=this.direction+("ccw"===this.rotation?1:-1)%4}_firstPoint(){switch(this.direction=4*this.divisions,"cw"===this.rotation&&this.direction++,this.current=this.interior?this.divisions+2:0,this.step=this.interior?2:0,this.levelCount=3,this.startCorner){case"ne":this.current=this.interior?2*this.divisions:this.divisions,this.direction+=3;break;case"se":this.current=this.interior?Math.pow(this.divisions,2)+this.divisions-2:Math.pow(this.divisions+1,2)-1,this.direction+=2;break;case"sw":this.current=this.interior?Math.pow(this.divisions,2):this.divisions*(this.divisions+1),this.direction+=1}return this.current}_nextPoint(){let t;const i=this.divisions-this.step;if(0===i)return t;switch(this.direction%4){case 0:t=this.current+i*(this.divisions+1);break;case 1:t=this.current+i;break;case 2:t=this.current-i*(this.divisions+1);break;case 3:t=this.current-i}return 0==--this.levelCount&&(++this.step,this.levelCount=2),this._nextDirection(),t}}class BoxSpirals extends Tangle{constructor(t,i){void 0===i&&(i={}),i.allowableOptions={size:50,desiredCount:void 0,divisions:void 0,rotation:void 0,startCorner:void 0,rotate:new Range(0,90)},super(t,i),this.build=function(){if(void 0===this.desiredCount){const t=isNaN(this.size)?this.size.min:this.size;this.desiredCount=Math.floor(this.width/t*this.height/t*10)}for(let t=0;t<this.desiredCount;t++){let t={size:Entanglement.getInt(this.size),fillColor:this.background};this.divisions&&(t.divisions=this.divisions),this.rotation&&(t.rotation=this.rotation),this.rotate&&(t.rotate=this.rotate),this.startCorner&&(t.startCorner=this.startCorner);new BoxSpiralElement(this.g,new Point(random(0,this.width),random(0,this.height)),t).draw()}},this.execute()}}class Ambler extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,void 0===i.gridShow&&(i.gridShow=!0),super(t,i),this.build=function(){const t=["nw","sw","se","ne"];let i=0,s=i+1;for(let e=0;e<this.gridPoints.length-1;e++){for(let s=0;s<this.gridPoints[e].length-1;s++){const n=this.gridPoints[e][s],h=this.gridPoints[e][s+1],o=this.gridPoints[e+1][s+1],r=this.gridPoints[e+1][s];BoxSpiralElement.newFromCoordinates(this.g,n,h,o,r,{startCorner:t[i%4],divisions:6,interior:!0}).draw(),i++}i=s++}},this.execute()}}class Emingle extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,void 0===i.gridShow&&(i.gridShow=!0),i.allowableOptions={startCorner:"nw"},super(t,i),this.build=function(){const t=["nw","sw","se","ne"];"random"===this.startCorner&&(this.startCorner=t[Math.floor(random(0,4))]);for(let t=0;t<this.gridPoints.length-1;t++)for(let i=0;i<this.gridPoints[t].length-1;i++){const s=this.gridPoints[t][i],e=this.gridPoints[t][i+1],n=this.gridPoints[t+1][i+1],h=this.gridPoints[t+1][i];BoxSpiralElement.newFromCoordinates(this.g,s,e,n,h,{startCorner:this.startCorner,divisions:6,interior:!0}).draw()}},this.execute()}}class Huggins extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,i.gridShow=!1,i.allowableOptions={holeDiameter:"proportional",holeFillColor:"black",holesShow:!0,curve:5},super(t,i),this.build=function(){"proportional"===this.holeDiameter&&(this.holeDiameter=Math.min(this.gridXSpacing,this.gridYSpacing)/4);const t=this.holeDiameter/2,i=this.curve*t;this.g.curveTightness(0);let s=[];for(let e=0;e<this.gridPoints.length;e++){let n=[];for(let s=0;s<this.gridPoints[e].length;s++){let h=[];h.push(new Polar(t,radians(225)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(315)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(45)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(t,radians(135)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(225)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(315)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(45)).toPointCenter(this.gridPoints[e][s])),h.push(new Polar(i,radians(135)).toPointCenter(this.gridPoints[e][s])),n.push(h)}s.push(n)}this.g.fill(0,0,0,0);let e=0,n=1;for(let t=0;t<this.gridPoints.length;t++){for(let i=0;i<this.gridPoints[t].length-1;i++){let n=s[t][i][7],h=s[t][i][0],o=s[t][i+1][1],r=s[t][i+1][6];e++%2&&(n=s[t][i][4],h=s[t][i][3],o=s[t][i+1][2],r=s[t][i+1][5]),this.g.curve(n.x,n.y,h.x,h.y,o.x,o.y,r.x,r.y)}e=n++}e=0,n=1;for(let t=0;t<this.gridPoints.length-1;t++){for(let i=0;i<this.gridPoints[t].length;i++){let n=s[t][i][4],h=s[t][i][1],o=s[t+1][i][2],r=s[t+1][i][7];e++%2&&(n=s[t][i][5],h=s[t][i][0],o=s[t+1][i][3],r=s[t+1][i][6]),this.g.curve(n.x,n.y,h.x,h.y,o.x,o.y,r.x,r.y)}e=n++}if(this.holesShow){this.g.fill(this.holeFillColor);for(let t=0;t<this.gridPoints.length;t++)for(let i=0;i<this.gridPoints[t].length;i++)this.g.circle(this.gridPoints[t][i].x,this.gridPoints[t][i].y,this.holeDiameter)}},this.execute()}}class W2 extends Tangle{constructor(t,i){void 0===i&&(i={}),i.grid=!0,i.gridShow=!1,i.allowableOptions={holeSize:"proportional",holeFillColor:"black",holesShow:!0},super(t,i),this.build=function(){"proportional"===this.holeSize&&(this.holeSize=Math.min(this.gridXSpacing,this.gridYSpacing)/4);const t=this.holeSize/2;let i=[];for(let s=0;s<this.gridPoints.length;s++){let e=[];for(let i=0;i<this.gridPoints[s].length;i++){let n=[];n.push(new Point(this.gridPoints[s][i].x-t,this.gridPoints[s][i].y-t)),n.push(new Point(this.gridPoints[s][i].x+t,this.gridPoints[s][i].y-t)),n.push(new Point(this.gridPoints[s][i].x+t,this.gridPoints[s][i].y+t)),n.push(new Point(this.gridPoints[s][i].x-t,this.gridPoints[s][i].y+t)),e.push(n)}i.push(e)}this.g.fill(0,0,0,0);let s=0,e=1;for(let t=0;t<this.gridPoints.length;t++){for(let e=0;e<this.gridPoints[t].length-1;e++){let n=i[t][e][1],h=i[t][e+1][0];s++%2&&(n=i[t][e][2],h=i[t][e+1][3]),this.g.line(n.x,n.y,h.x,h.y)}s=e++}s=0,e=1;for(let t=0;t<this.gridPoints.length-1;t++){for(let e=0;e<this.gridPoints[t].length;e++){let n=i[t][e][2],h=i[t+1][e][1];s++%2&&(n=i[t][e][3],h=i[t+1][e][0]),this.g.line(n.x,n.y,h.x,h.y)}s=e++}if(this.holesShow){this.g.fill(this.holeFillColor);for(let t=0;t<this.gridPoints.length;t++)for(let s=0;s<this.gridPoints[t].length;s++)this.g.rect(i[t][s][0].x,i[t][s][0].y,this.holeSize,this.holeSize)}},this.execute()}}class Zentangle extends TangleBase{constructor(t,i,s){super(),void 0===s&&(s={}),s.allowableOptions={background:255,borderSize:30},this.loadOptions(s),this.width=t,this.height=t,this.shape=void 0===i?"square":i,"triangle"===this.shape&&(this.height*=.87),this.g=createGraphics(this.width,this.height);let e=new Point(this.width/2,this.height/2);switch(this.shape){case"circle":this.edgePoly=new Polygon;for(let t=0;t<360;t++)this.edgePoly.addVertex(new Polar(this.width/2-1,radians(t)).toPointCenter(e));this.borderPoly=new Polygon;for(let t=0;t<360;t++)this.borderPoly.addVertex(new Polar(this.width/2-this.borderSize,radians(t)).toPointCenter(e).vary(1));break;case"triangle":e=new Point(this.width/2,2*this.height/3),this.edgePoly=new Polygon([new Point(0,this.height),new Point(this.width/2,0),new Point(this.width,this.height)]);const t=2*this.height/3-2*this.borderSize;this.borderPoly=this._createBorderPolyFromLines([new Polar(t,radians(270)).toPointCenter(e),new Polar(t,radians(30)).toPointCenter(e),new Polar(t,radians(150)).toPointCenter(e)]);break;default:this.edgePoly=new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)]),this.borderPoly=this._createBorderPolyFromLines([new Point(this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.borderSize),new Point(this.width-this.borderSize,this.height-this.borderSize),new Point(this.borderSize,this.height-this.borderSize)])}this.areas=[],createCanvas(this.width,this.height),background(this.background)}getFullMask(){return new Polygon([new Point(0,0),new Point(this.width,0),new Point(this.width,this.height),new Point(0,this.height)])}addTangle(t){this.areas.push(t),this.g.image(t.g,t.origin.x,t.origin.y)}draw(){let t,i=createGraphics(this.width,this.height);i.noStroke(),i.fill(255,255,255,0),i.beginShape();for(let t=0;t<this.edgePoly.vertices.length;t++)i.vertex(this.edgePoly.vertices[t].x,this.edgePoly.vertices[t].y);i.endShape(CLOSE),i.fill(255,255,255,255),i.beginShape();for(let t=0;t<this.borderPoly.vertices.length;t++)i.vertex(this.borderPoly.vertices[t].x,this.borderPoly.vertices[t].y);i.endShape(CLOSE),(t=this.g.get()).mask(i.get()),image(t,0,0),stroke(0),fill(255,255,255,0),beginShape();for(let t=0;t<this.borderPoly.vertices.length;t++)vertex(this.borderPoly.vertices[t].x,this.borderPoly.vertices[t].y);endShape(CLOSE),beginShape();for(let t=0;t<this.edgePoly.vertices.length;t++)vertex(this.edgePoly.vertices[t].x,this.edgePoly.vertices[t].y);endShape(CLOSE)}_createBorderPolyFromLines(t){let i=new Polygon;for(let s=0;s<t.length;s++){let e=s+1;e===t.length&&(e=0);const n=new Line(t[s],t[e]).handDrawn();for(let t=0;t<n.length;t++)i.addVertex(n[t])}return i}}
