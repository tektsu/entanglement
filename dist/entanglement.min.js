class Point{constructor(t,i){this.x=t,this.y=i}add(t){this.x+=t.x,this.y+=t.y}}class Polar{constructor(t,i){this.r=t,this.a=i}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(t){let i=this.toPoint();return i.add(t),i}}class Box{constructor(t,i,s){this.position=t,this.width=void 0===i?100:i,this.height=void 0===s?100:s}static newFromXY(t,i,s,a){return void 0===t&&(t=0),void 0===i&&(i=0),new Box(new Point(t,i),s,a)}}class Range{constructor(t,i){t>i?(this.min=i,this.max=t):(this.min=t,this.max=i)}rand(){return random(this.min,this.max)}}class TangleElement{constructor(t,i){this.size=void 0===t?100:t,this.center=null==i?Point(0,0):i,this.poly=[],this.debug=!1,this.fillColor=0,this.strokeColor=0}loadOptions(t){if(void 0!==t)for(const i in t)this[i]=t[i]}addVertex(t){this.poly.push(createVector(t.x,t.y))}getPoly(){return this.poly}drawPoly(){if(this.debug){fill(128,0,0,128),beginShape();for(let t=0;t<this.poly.length;++t)vertex(this.poly[t].x,this.poly[t].y);endShape(CLOSE)}}draw(){fill(this.fillColor),stroke(this.strokeColor)}}class Tangle{constructor(t){this.box=t,this.debug=!1}loadOptions(t){if(void 0!==t)for(const i in t)this[i]=t[i]}collisionTest(t){if(!this.avoidCollisions)return!1;for(let i=0;i<this.polys.length;++i)if(collidePolyPoly(t,this.polys[i],!0))return!0;return!1}}class Dot extends TangleElement{constructor(t,i,s){super(t,i),this.spacing=400,this.loadOptions(s),this.spacing=Math.max(100,this.spacing);let a=TWO_PI/8;for(let t=0;t<TWO_PI;t+=a)this.addVertex(new Polar(this.spacing/100*this.size,t).toPointCenter(this.center))}draw(){super.draw(),circle(this.center.x,this.center.y,this.size),this.drawPoly()}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(t,i,s){super(t,i),this.armCount=8,this.thetaSD=5,this.lengthSDP=15,this.gapSDP=10,this.rotate=!0,this.tipDistancePercent=100,this.tipDiameter=Aah.tipType.gap,this.loadOptions(s),this.length=t/2,this.armCount<3&&(this.armCount=3),this.arms=[];const a=TWO_PI/this.armCount,o=this.rotate?random(0,a):0;for(let t=0;t<TWO_PI-a/2;t+=a){let i=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(t+o,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(s,i.a).toPointCenter(this.center),stop:i.toPointCenter(this.center),tipCenter:new Polar(i.r*(this.tipDistancePercent/100),i.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(h);let e=Math.max(i.r,i.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(e+5*s,i.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*i.r,i.a+a/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(t=>{line(t.start.x,t.start.y,t.stop.x,t.stop.y),circle(t.tipCenter.x,t.tipCenter.y,t.tipDiameter)}),this.drawPoly()}}class Aahs extends Tangle{static plans={zentangle:{aah:{},dot:{size:new Range(3,6),fillColor:255}}};constructor(t,i){super(t),this.polys=[],this.avoidCollisions=!0,this.plan=Aahs.plans.zentangle,this.loadOptions(i),void 0===this.plan.aah&&(this.plan.aah={}),void 0===this.plan.dot&&(this.plan.dot={})}draw(){if(void 0===this.plan.aah.enable||!0===this.plan.aah.enable){let t=0,i=0;const s=void 0===this.plan.aah.size?Math.min(this.box.width,this.box.height)/8:this.plan.aah.size;void 0===this.margin&&(this.margin=s/6);const a=void 0===this.plan.aah.desiredCount?this.box.width/s*(this.box.height/s)*10:this.plan.aah.desiredCount;console.log(a);const o=void 0===this.plan.aah.sizeSDP?this.plan.aah.sizeSDP/100*s:this.plan.aah.sizeSDP;for(;t<a;){let h=new Point(random(this.box.position.x+this.margin,this.box.width-this.margin),random(this.box.position.y+this.margin,this.box.height-this.margin)),e={debug:this.debug};void 0!==this.plan.aah.armCount&&(e.armCount=this.plan.aah.armCount),void 0!==this.plan.aah.thetaSD&&(e.thetaSD=this.plan.aah.thetaSD),void 0!==this.plan.aah.lengthSDP&&(e.lengthSDP=this.plan.aah.lengthSDP),void 0!==this.plan.aah.gapSDP&&(e.gapSDP=this.plan.aah.gapSDP),void 0!==this.plan.aah.rotate&&(e.rotate=this.plan.aah.rotate),void 0!==this.plan.aah.tipDistancePercent&&(e.tipDistancePercent=this.plan.aah.tipDistancePercent),void 0!==this.plan.aah.tipDiameter&&(e.tip.diameter=this.plan.aahTipDiameter),void 0!==this.plan.aah.fillColor&&(e.fillColor=this.plan.aah.fillColor),void 0!==this.plan.aah.strokeColor&&(e.strokeColor=this.plan.aah.strokeColor);const n=new Aah(randomGaussian(s,o),h,e),r=n.getPoly();if(this.collisionTest(r)){if(++i,i>3*a)break}else this.polys.push(r),n.draw(),++t}}if(void 0===this.plan.dot.enable||!0===this.plan.dot.enable){const t=void 0===this.plan.dot.size?3:this.plan.dot.size,i=!isNaN(t),s=2*(i?t:t.max),a=this.box.width/s*(this.box.height/s);for(let s=0;s<a;++s){const s=new Point(random(this.box.position.x+this.margin,this.box.width-this.margin),random(this.box.position.y+this.margin,this.box.height-this.margin)),a=i?t:t.rand();let o={debug:this.debug};void 0!==this.plan.dot.spacing&&(o.spacing=this.plan.dot.spacing),void 0!==this.plan.dot.fillColor&&(o.fillColor=this.plan.dot.fillColor),void 0!==this.plan.dot.strokeColor&&(o.strokeColor=this.plan.dot.strokeColor);const h=new Dot(a,s,o),e=h.getPoly();this.collisionTest(e)||(this.polys.push(e),h.draw())}}return this.polys}}
