class Point{constructor(t,i){this.x=t,this.y=i}add(t){this.x+=t.x,this.y+=t.y}}class Polar{constructor(t,i){this.r=t,this.a=i}toPoint(){return new Point(this.r*cos(this.a),this.r*sin(this.a))}toPointCenter(t){let i=this.toPoint();return i.add(t),i}}class Box{constructor(t,i,s){this.position=t,this.width=void 0===i?100:i,this.height=void 0===s?100:s}static newFromXY(t,i,s,e){return void 0===t&&(t=0),void 0===i&&(i=0),new Box(new Point(t,i),s,e)}}class Range{constructor(t,i){t>i?(this.min=i,this.max=t):(this.min=t,this.max=i)}rand(){return random(this.min,this.max)}}class TangleElement{constructor(t,i){this.size=void 0===t?100:t,this.center=null==i?Point(0,0):i,this.poly=[],this.debug=!1,this.drawPre=function(){fill(0,0,0),stroke(0,0,0)}}loadOptions(t){if(void 0!==t)for(const i in t)this[i]=t[i]}addVertex(t){this.poly.push(createVector(t.x,t.y))}getPoly(){return this.poly}drawPoly(){if(this.debug){fill(128,0,0,128),beginShape();for(let t=0;t<this.poly.length;++t)vertex(this.poly[t].x,this.poly[t].y);endShape(CLOSE)}}draw(){void 0!==this.drawPre&&this.drawPre()}}class Tangle{constructor(t){this.box=t,this.debug=!1}loadOptions(t){if(void 0!==t)for(const i in t)this[i]=t[i]}collisionTest(t){if(!this.avoidCollisions)return!1;for(let i=0;i<this.polys.length;++i)if(collidePolyPoly(t,this.polys[i],!0))return!0;return!1}}class Dot extends TangleElement{constructor(t,i,s){super(t,i),this.spacing=400,this.loadOptions(s),this.spacing=Math.max(150,this.spacing);let e=TWO_PI/8;for(let t=0;t<TWO_PI;t+=e)this.addVertex(new Polar(this.spacing/100*this.size,t).toPointCenter(this.center))}draw(){super.draw(),circle(this.center.x,this.center.y,this.size),this.drawPoly()}}class Aah extends TangleElement{static tipType={gap:"gap"};constructor(t,i,s){super(t,i),this.armCount=8,this.thetaSD=5,this.lengthSDP=15,this.gapSDP=10,this.rotate=!0,this.tipDistancePercent=100,this.tipDiameter=Aah.tipType.gap,this.loadOptions(s),this.length=t/2,this.armCount<3&&(this.armCount=3),this.arms=[];const e=TWO_PI/this.armCount,a=this.rotate?random(0,e):0;for(let t=0;t<TWO_PI-e/2;t+=e){let i=new Polar(randomGaussian(this.length,this.lengthSDP/100*this.length),randomGaussian(t+a,this.thetaSD*Math.PI/180));const s=randomGaussian(this.gapSDP,this.gapSDP/7)/100*this.length;let h={start:new Polar(s,i.a).toPointCenter(this.center),stop:i.toPointCenter(this.center),tipCenter:new Polar(i.r*(this.tipDistancePercent/100),i.a).toPointCenter(this.center),tipDiameter:isNaN(this.tipDiameter)?this.tipDiameter===Aah.tipType.gap?s:10:this.tipDiameter};this.arms.push(h);let n=Math.max(i.r,i.r*(this.tipDistancePercent/100))+h.tipDiameter/2;this.addVertex(new Polar(n+5*s,i.a).toPointCenter(this.center)),this.addVertex(new Polar(.6*i.r,i.a+e/2).toPointCenter(this.center))}this.debug&&console.log("aah: ",this.aah)}draw(){super.draw(),this.arms.forEach(t=>{line(t.start.x,t.start.y,t.stop.x,t.stop.y),circle(t.tipCenter.x,t.tipCenter.y,t.tipDiameter)}),this.drawPoly()}}class Aahs extends Tangle{static plans={zentangle:{aahs:!0,dots:!0,dotSize:new Range(3,6),dotDrawPre:function(){fill(255,255,255),stroke}}};constructor(t,i){super(t),this.polys=[],this.size=Math.min(t.width,t.height)/8,this.sizeSDP=15,this.margin=this.size/6,this.avoidCollisions=!0,this.plan=Aahs.plans.zentangle,this.loadOptions(i)}draw(){if(this.plan.aahs){let t=0,i=0;void 0===this.desiredCount&&(this.desiredCount=this.box.width/this.size*(this.box.height/this.size)*10);let s=this.sizeSDP/100*this.size;for(;t<this.desiredCount;){let e=new Point(random(this.box.position.x+this.margin,this.box.width-this.margin),random(this.box.position.y+this.margin,this.box.height-this.margin)),a={debug:this.debug};void 0!==this.plan.aahDrawPre&&(a.drawPre=this.plan.aahDrawPre),void 0!==this.plan.aahArmCount&&(a.armCount=this.plan.aahArmCount),void 0!==this.plan.aahThetaSD&&(a.thetaSD=this.plan.aahThetaSD),void 0!==this.plan.aahLengthSDP&&(a.lengthSDP=this.plan.aahLengthSDP),void 0!==this.plan.aahGapSDP&&(a.gapSDP=this.plan.aahGapSDP),void 0!==this.plan.aahRotate&&(a.rotate=this.plan.aahRotate),void 0!==this.plan.aahTipDistancePercent&&(a.tipDistancePercent=this.plan.aahTipDistancePercent),void 0!==this.plan.aahTipDiameter&&(a.tipDiameter=this.plan.aahTipDiameter),console.log(this.plan,a);const h=new Aah(randomGaussian(this.size,s),e,a),n=h.getPoly();if(this.collisionTest(n)){if(++i,i>3*this.desiredCount)break}else this.polys.push(n),h.draw(),++t}}if(this.plan.dots){const t=void 0===this.plan.dotSize?3:this.plan.dotSize,i=!isNaN(t),s=2*(i?t:t.max),e=this.box.width/s*(this.box.height/s);for(let s=0;s<e;s++){const s=new Point(random(this.box.position.x+this.margin,this.box.width-this.margin),random(this.box.position.y+this.margin,this.box.height-this.margin)),e=i?t:t.rand();let a={debug:this.debug};void 0!==this.plan.dotDrawPre&&(a.drawPre=this.plan.dotDrawPre),void 0!==this.plan.dotSpacing&&(a.spacing=this.plan.dotSpacing);const h=new Dot(e,s,a),n=h.getPoly();this.collisionTest(n)||(this.polys.push(n),h.draw())}}return this.polys}}
